# 	七、聚合函数

聚合函数作用于一组数据，返回一个值。

## 1、常用聚合函数

### 1.1 AVG和SUM函数

- AVG求平均值

- SUM求和

只能对**数值型数据**使用。

```mysql
# 使用示例，求 工资 salary
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)
FROM  employees
WHERE job_id LIKE '%REP%';
```

> 注意：AVG 和 SUM 会自动过滤掉 NULL。
>
> 公式：AVG = SUM / COUNT

### 1.2 MIN和MAX函数

- MIN 求最小值

- MAX 求最大值

对**任意数据类型**都能使用。

```mysql
# 使用示例，求 日期 salary
SELECT MIN(hire_date), MAX(hire_date)
FROM employees;
```

### 1.3 COUNT函数

- COUNT 计算指定字段在查询结果中出现的个数

对**任意数据类型**都能使用。



- COUNT(*)返回表中记录总数，适用于任意数据类型。

```mysql
# 使用示例，求 表中记录总数，* 表示所有
SELECT COUNT(*)
FROM employees
WHERE department_id = 50;
```

- COUNT(expr) 返回expr不为空的记录总数。

> expr 一般都表示 值/表达式

```mysql
# 使用示例，求 字段 commission_pct 在表中出现的个数
SELECT COUNT(commission_pct)
FROM  employees
WHERE department_id = 50;
```

> 注意：count(列名)**不会统计此列为 NULL 值的行**(自动过滤 NULL 值)，count(*) 会统计值为 NULL 的行
>
> 统计一个表中总共有多少条记录，推荐使用 count(*)，1是不会有误差，2是效率比 count(列名) 的方式高

> 补充：关于自己的思考，`count(*)` 在统计已经被分组分好的数据时，是统计每一组数据的行数并返回，毕竟 `count(*)` 表示的就是统计总共有多少条记录，只要有记录，就会被统计。
>
> 分组指定条件的重复数据划分为不同组，然后再由 select 执行 count(`*`) 时，count(`*`) 就不再是统计所有的行数并返回了，而是统计每一个组的所有行数并返回。

## 2、分组-GROUP BY

### 2.1 基本使用

GROUP BY 可以将表中的数据分成若干组。

```mysql
# 示例
SELECT column, group_function(column)
FROM table
[WHERE condition]
[GROUP BY group_by_expression]
[ORDER BY column];
```

> **明确：WHERE 一定放在 FROM 后面**
>
> 声明位置：
>
> 1、WHERE 在 FROM 后面
>
> 2、GROUP BY 在 WHERE 后面
>
> 3、ORDER BY 在 GROUP BY 后面
>
> 4、LIMIT 在 ORDER BY 后面
>
> 即 FROM --> WHERE --> GROUP BY --> ORDER BY --> LIMIT

**注意：**

1. SELECT 所查询的字段（不包含组函数），必须在 GROUP BY 中都存在
2. GROUP BY 中存在的字段，在 SELECT 中可以不存在。
3. 总结：SELECT 有的 GROUP BY 必须有，BROUP BY 有的，SELECT 可以没有。

### 2.2 多列分组

```mysql
# 示例
SELECT  department_id dept_id, job_id, SUM(salary)
FROM   employees
GROUP BY department_id, job_id ;# 直接在 GROUP BY 中加上需要分组的列即可
```

### 2.3 WITH ROLLUP

WITH ROLLUP 会在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。

```mysql
SELECT department_id,AVG(salary)
FROM employees
WHERE department_id > 80
GROUP BY department_id WITH ROLLUP;
```

注意：

- 当使用 ROLLUP 时，不能同时使用 ORDER BY 子句进行结果排序，即 **ROLLUP 和 ORDER BY 是互相排斥的。**

## 3、过滤-HAVING

### 3.1 基本使用

**作用：**满足HAVING 子句中条件的分组将被显示。

**使用前提：**

1. 行已经被分组。
2. 使用了聚合函数。
3. 必须要跟 GROUP BY 一起使用

**声明位置：**在 GROUP BY 之后



### 3.2 与 WHERE 的对比

**WHERE 子句中，不能使用聚合函数**

> 但是 HAVING 可以使用聚合函数，但是必须绑定 GROUP BY 

```mysql
# 错误示例
SELECT  department_id, AVG(salary)
FROM   employees
WHERE  AVG(salary) > 8000
GROUP BY department_id;
# 会报错
```

|        | 优点                         | 缺点                                   |
| ------ | ---------------------------- | -------------------------------------- |
| WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |
| HAVING | 可以使用分组中的计算函数     | 在最后的结果集中进行筛选，执行效率较低 |

> WHERE 先筛选数据在连接，HAVING 先进行连接，再进行数据的筛选。

**开发中的选择：**

都要(二者并不是互相排斥的)，包含分组统计函数的条件用 HAVING，普通条件用 WHERE。

## 4、SELECT的执行过程

### 4.1 查询结构

```mysql
#方式1：SQL92 语法
SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...


#方式2：SQL99 语法
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...


#其中：
#（1）from：从哪些表中筛选
#（2）on：关联多表查询时，去除笛卡尔积
#（3）where：从表中筛选的条件
#（4）group by：分组依据
#（5）having：在统计结果中再次筛选
#（6）order by：排序
#（7）limit：分页
```

### 4.2 SELECT执行顺序

```mysql
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```

> 关键字的顺序是不能颠倒的

**SELECT语句的执行顺序**

```mysql
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
```

> 在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同

```mysql
# 示例，流程顺序示意程序
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```

> 补充：在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个**虚拟表**，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。

> 再补充：如果是多表查询，首先得到的就是一个笛卡尔积的数据，然后再根据 ON 的条件进行过滤，之后就是一步一步的按着执行顺序的流程走了。
