# 十一、泛型

## 1、概述

### 1.1 概念

1）泛型 == 广泛（泛）的类型（型），与这个相反，这个东西的作用恰恰就是限制广泛的类型

> ​	其实就是数据类型的类型（即形参，类型的形参），即可以动态的表示任意一个数据类型，这个可以根据实参的数据类型，动态的表示任意数据类型，可以理解为类型变量，但是不是int之类的数据类型了，而是对象的类型或者自己定义的一个类型
>
> 有点类似于形参，只不过类型可以根据传入的对象的类型而改变,也可以理解为类型的形参
>
> 类型的形式参数

2）泛型又称 参数化类型，是 JDK5.0 出现的新特性，解决数据类型的安全性问题

3）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。

### 1.2 好处

1）在 **类声明** 或 **实例化** 时只要指定好需要的具体的类型即可

2）Java 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮

3）编译时，检查添加元素的类型，提高了安全性

4）减少了类型转换的次数，提高效率

> 使用迭代器遍历集合时，可以省略向下转型的步骤（因为限制了存放的类型，取出的类型自然就只能为存放的类型）

5）解决数据安全的问题，就是可以约束数据类型的种类

6）可以在类声明时通过一个标识符（用尖括号：<> 表示，里面放的表示数据类型的一个形参就是泛型）表示类中的某个属性的类型，或者是某个方法返回值的类型，或者是参数类型

> 可以直观的表示出一个集合中都有什么数据类型

### 1.3 代码解释

```java
public class Generic03 {
	public static void main(String[] args) {
	//注意，特别强调： E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型
        Person<String> person = new Person<String>("韩顺平教育");
        person.show(); //String
    /*
    你可以这样理解，上面的 Person 类
class Person {
	String s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,
		即在编译期间，就确定 E 是什么类型
	public Person(String s) {//E 也可以是参数类型
		this.s = s;
	}
	public String f() {//返回类型使用 E
		return s;
	}
}
	*/
        Person<Integer> person2 = new Person<Integer>(100);
        person2.show();//Integer
    /*
class Person {
    Integer s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,
    即在编译期间，就确定 E 是什么类型
	public Person(Integer s) {//E 也可以是参数类型
		this.s = s;
	}
	public Integer f() {//返回类型使用 E
		return s;
	}
}
*/
	}
}
```

## 2、语法

### 2.1 声明

```java
interface 接口<T> {}//接口的泛型声明
class 类<K,V>{)//类的泛型声明
```

**说明**：

1）其中，T,K,V不代表值，而是表示类型

2）任意字母都可以，常用 T 表示，是 Type 的缩写

### 2.2 实例化

1）在指定泛型具体类型后，可以传入该类型或者其子类类型

**泛型使用形式**：

   ```java
   List<Integer> list1 = new ArrayList<Integer>();
   List<Integer> list2 = new ArrayList<>();
   //右边泛型省略，编译器会进行类型推断，即左边括号里是什么，编译器会自动认为右边括号里的就是什么
   ```

2）不标泛型则默认泛型为 Object

```java
//例如：
List list3 = new ArrayList();
//如果我们这样写默认给它的泛型是 <E>，E 就是 Object
```

3）泛型里面可以存放自己自定义的类型（即可以在一个类里面放入另一个类的数据类型）

```java
//例如：类A，类B，则可以写成
A <B> 名字  = new A<>();
```

### 2.3 细节

1）泛型只能是 引用类型

```java
interface List<T>{,public class HashSet<E>)..
//说明：T,E只能是引用类型
```

2）在给泛型指定具体类型后，可以传入该类型或者其子类类型

3）泛型使用形式

```java
List<Integer>list1 new ArrayList<Integer>();
List<Integer>list2=new ArrayList<>();
```

> //右边泛型省略，编译器会进行类型推断，即左边括号里是什么，编译器会自动认为右边括号里的就是什么

4）如果我们这样写

```java
List list3=new ArrayList();
```

> 默认给它的泛型是[ <E> E 就是 Object ]

## 3、自定义泛型类

### 3.1 基本语法

   ```java
   class 类名<T,R...>{成员}
   //自己写一个类，自己去定义了一个或一些泛型（限制数据类型）
   //这种类被称为自定义泛型类
   ```
### 3.2 细节：

1）普通成员可以使用泛型（属性、方法）

> 及普通属性可以用泛型来当自己的数据类型，方法的返回值和形参的类型都可以设置成泛型

2）使用泛型的数组，不能初始化

> 因为数组在 new 的时候不能确定 T 的类型，就无法在内存开空间
>
> T[] ts; 但是不能给 T 数组指定大小（就是不能在 [] 这个中括号中给定具体的数值，数组的初始化就指的这个（妈的，又给忘了））

3）静态方法中不能使用类的泛型

> 涉及形参，就涉及到多态，是动态的
>
> 因为静态是和类相关的，与对象是没有关系的，在类加载的时候，就要加载静态属性和方法，这个时候用泛型，编译器会不明白到底是代表的哪种数据类型
>
> JVM就无法完成类的初始化，泛型的类型是随着对象的创建而指定，而静态成员是随着类的加载就会初始化的

4）泛型类的类型，是在创建对象时确定的（因为创建对像时，需要指定确定类型）

5）如果在创建对象时，没有指定类型，默认为Object

6）泛型的标识符（ <这个尖括号里的东西> ）一般为单个的大写字母

### 3.3 自定义泛型接口：

1）**基本语法**：

   ```java
   interface 接口明<T,R...>{}
   ```

2）**注意细节**：

- 接口中，静态成员也不能使用泛型（这个和泛型类规定一样）
- 泛型接口的类型，在**继承接口**或者**实现接口**时确定
- 没有指定类型，默认为Object

### 3.4 自定义泛型方法

1）**基本语法**：

```java
修饰符 <T,R...>返回类型 方法名(T t,R r){}
```

2）**注意细节**：

- 泛型方法，可以定义在普通类中，也可以定义在泛型类中

> 泛型方法，可以使用自定义的泛型，也可使用类定义的泛型

- 泛型方法被调用时，类型会确定

> ​	这个属于是方法调用泛型，不过只能调用类里自定义的泛型，与自定义泛型的不同点在于，自定义的泛型方法里的泛型可以根据自身需求随意定义，并使用；而方法调用泛型只能调用自定义泛型类里已经定义好了的泛型（或者说调用类声明的泛型）。

- `public void eat(E e) {}`,修饰符后没有<T,R...> ，eat方法不是泛型方法，而是使用了泛型

## 4、泛型的继承和通配符

### 4.1 概述

1）泛型不具备继承性

2）<?>：支持任意泛型类型

3）<? extends A>:支持A类以及A类的子类，规定了泛型的上限

> 表示可以接收 AA 或者 AA 子类

4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限

> 支持AA类或者AA类的父类

只能用在方法调用泛型的时候，它可以接收任意类型的泛型类型

```java
        List<Object> list1 = new ArrayList<>();
        List<String> list2 = new ArrayList<>();
        List<AA> list3 = new ArrayList<>();
        List<BB> list4 = new ArrayList<>();
        List<CC> list5 = new ArrayList<>();
        //说明：L1st<?>表示任意的泛型类型都可以接受
        //即上面的List<>的泛型中可以为任意类型
        //这样的好处是  不受类声明的泛型被其他类型占用时，单独要用另外一种数据类型来使用这个方法的时候，这个方法的好处就体现出来了
        public static void printCollection1(List<?> c){
        for(Object object : c){//通配符，取出时，就是Object
        System.out.println(object);
        }
```