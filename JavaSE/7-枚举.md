# 七、枚举

## 1、概念：

​	**关键字：enum**

​	一个一个的将对象列举出来的类，称之为枚举类

## 2、应用：

### 2.1 使用场景

​	在我们需要一个对象值(数量)是确定的，外人不能随意的去添加对象，且不能随意的去修改对象的基本属性的情况下，我们需要枚举类

### 2.2 使用细节

枚举是一组常量的集合(特殊的类，只包含一组有限的特定的对象)

- 枚举类会默认继承Enum类,且本身会是一个final的类
- 使用无参构造器创建枚举对象时，实参列表可省略
- 枚举类不能继承其他类（继承了Enum类）
- 枚举类可以实现接口

### 2.3 使用

#### 2.3.1 自定义类实现枚举

```java
//演示字定义枚举实现
class Season {//类
private String name;
private String desc;//描述
//定义了四个对象, 固定.
public static final Season SPRING = new Season("春天", "温暖");
public static final Season WINTER = new Season("冬天", "寒冷");
public static final SeasonAUTUMN = new Season("秋天", "凉爽");
public static final Season SUMMER = new Season("夏天", "炎热");
//1. 将构造器私有化,目的防止 直接 new
//2. 去掉 setXxx 方法, 防止属性被修改
//3. 在 Season 内部，直接创建固定的对象
//4. 优化，可以加入 final 修饰符
private Season(String name, String desc) {
this.name = name;
this.desc = desc;
}
public String getName() {
return name;
}
public String getDesc() {
return desc;
}
@Override
public String toString() {
return "Season{" +
"name='" + name + '\'' +
", desc='" + desc + '\'' +
'}';
}
}
```

> 总结：自定义实现枚举类有如下特点
>
> 1) 构造器私有化
> 2) 本类内部创建一组对象[四个 春夏秋冬]
> 3) 对外暴露对象（通过为对象添加 public final static 修饰符）
> 4) 可以提供 get 方法，但是不要提供 set

#### 2.3.2 系统关键字 enum 实现枚举

```java
补充：final 修饰的，名字全部大写//演示使用 enum 关键字来实现枚举类
enum Season2 {//类
//定义了四个对象, 固定.
// public static final Season SPRING = new Season("春天", "温暖");
// public static final Season WINTER = new Season("冬天", "寒冷");
// public static final Season AUTUMN = new Season("秋天", "凉爽");
// public static final Season SUMMER = new Season("夏天", "炎热");
//如果使用了 enum 来实现枚举类
//1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season("春天", "温暖") 直接使用 SPRING("春天", "温暖") --> 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
SPRING("春天", "温暖"), WINTER("冬天", "寒冷"), AUTUMN("秋天", "凉爽"),
SUMMER("夏天", "炎热")/*, What()*/;
private String name;
private String desc;//描述
private Season2() {//无参构造器
}
private Season2(String name, String desc) {
this.name = name;
this.desc = desc;
}
public String getName() {
return name;
}
public String getDesc() {
return desc;
}
@Override
public String toString() {
return "Season{" +
"name='" + name + '\'' +
", desc='" + desc + '\'' +
'}';
}
}
```

> enum 关键字实现枚举注意事项：
>
> 1、当我们使用enum 关键字开发一个枚举类时，默认会继承Enum类, 而且是一个final 类[如何证明],老师使用javap 工
> 具来演示
>
> 2、传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); 简化成 SPRING("春天", "温暖")， 这里必须知道，它调用的是哪个构造器.
>
> 3、如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略
>
> 4、当有多个枚举对象时，使用 , 间隔，最后有一个分号结尾
>
> 5、枚举对象必须放在枚举类的行首.



> 补充：
>
> 枚举对象命名规范：全大写
>
> final 修饰的，名字全部大写
>
> 对枚举对象用 static 和 final 共同修饰，实现底层的优化

#### 2.3.3 Enum类的常用方法

> 说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。

| 方法      | 效果                                                         |
| --------- | ------------------------------------------------------------ |
| name      | 返回当前对象名，子类不可重写，用来返回对象的属性信息         |
| ordinal   | 返回当前对象的位置号，默认从零开始                           |
| toString  | 返回当前对象名，子类可重写                                   |
| values    | 返回当前枚举类中所有的常量                                   |
| valueOf   | 将字符串转换成枚举对象，要求字符串必须为已有的常量名（即可以查找到的枚举类中的对象常量），否则会报异常 |
| compareTo | 比较两个枚举类编号之差，即  前一个的编号  减  后一个的编号   的   值 |

#### 2.3.4 增强for循环:

```java
int[] nums = {1,2,9};
//普通的for循环
System.oUt.println("=====普通的for====");
for (int i = 0;i < nums.length; i++){
System.out.println(nums[i]);
	}
System.oUt.println("=====增强的for====");
//执行流程是  依次从nums数组中取出数据，赋给i,如果取出完毕，则退出for
for(int i : nums){
System.out.println("i=" + i);
}
```

> 比原for循环，更加的简洁

## 3、注解

### 3.1 注解概述

​	英文：**Annotation**

1、注解 (Annotation) 也被称为元数据 (Metadata) ，**用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息**。

2、和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

3、在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角
色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。

### 3.2 基本的 Annotation 介绍

#### 3.2.1 @Override

```java
class Father{//父类
public void fly(){
System.out.println("Father fly...");
}
public void say(){}
}

class Son extends Father {//子类
//老韩解读
//1. @Override 注解放在 fly 方法上，表示子类的 fly 方法时重写了父类的 fly
//2. 这里如果没有写 @Override 还是重写了父类 fly
//3. 如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误
//4. 看看 @Override 的定义
// 解读： 如果发现 @interface 表示一个 注解类
/*
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
*/
@Override //说明
public void fly() {
System.out.println("Son fly....");
}
@Override
public void say() {}
}
```

> 总结：
>
> 限定某个方法，为重写父类的方法，该注解**只能用于方法**
>
> **价值在于做语法校验**（如果没有对父类方法进行重写就会报错，从编译层面进行语法校验）

#### 3.2.2 @Deprecated

```java
public class Deprecated_ {
public static void main(String[] args) {
		Aa = new A();
		a.hi();
		System.out.println(a.n1);
	}
}
//老韩解读
//1. @Deprecated 修饰某个元素, 表示该元素已经过时
//2. 即不在推荐使用，但是仍然可以使用
//3. 查看 @Deprecated 注解类的源码
//4. 可以修饰方法，类，字段, 包, 参数 等等
//5. @Deprecated 可以做版本升级过渡使用
/*
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
*/
@Deprecated
class A{
@Deprecated
public int n1 = 10;
@Deprecated
public void hi(){
}
}
```

> 总结：
>
> 用于表示某个程序元素（类，方法等）**已过时**
>
> 即**不推荐使用，但是仍然可以使用**
>
> 可以做过渡使用（例如，版本升级导致某一些类的更新啥啥啥的）

#### 3.2.3 @SuppressWarnings

```java
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
public class SuppressWarnings_ {
//老韩解读
//1. 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息
//2. 在{""} 中，可以写入你希望抑制(不显示)警告信息
//3. 可以指定的警告类型有
// all，抑制所有警告
// boxing，抑制与封装/拆装作业相关的警告
// cast，抑制与强制转型作业相关的警告
// dep-ann，抑制与淘汰注释相关的警告
// deprecation，抑制与淘汰的相关警告
// fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告
// finally，抑制与未传回 finally 区块相关的警告
// hiding，抑制与隐藏变数的区域变数相关的警告
// incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告
// javadoc，抑制与 javadoc 相关的警告
// nls，抑制与非 nls 字串文字相关的警告
// null，抑制与空值分析相关的警告
// rawtypes，抑制与使用 raw 类型相关的警告
// resource，抑制与使用 Closeable 类型的资源相关的警告
// restriction，抑制与使用不建议或禁止参照相关的警告
// serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告
// static-access，抑制与静态存取不正确相关的警告
// static-method，抑制与可能宣告为 static 的方法相关的警告
// super，抑制与置换方法相关但不含 super 呼叫的警告
// synthetic-access，抑制与内部类别的存取未最佳化相关的警告
// sync-override，抑制因为置换同步方法而遗漏同步化的警告
// unchecked，抑制与未检查的作业相关的警告
// unqualified-field-access，抑制与栏位存取不合格相关的警告
// unused，抑制与未用的程式码及停用的程式码相关的警告
//4. 关于 SuppressWarnings 作用范围是和你放置的位置相关
// 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main
// 通常我们可以放置具体的语句, 方法, 类.
//5. 看看 @SuppressWarnings 源码
//(1) 放置的位置就是 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE
//(2) 该注解类有数组 String[] values() 设置一个数组比如 {"rawtypes", "unchecked", "unused"}
/*
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
String[] value();
}
*/
public static void main(String[] args) {
	List list = newArrayList();
	list.add("jack");
	list.add("tom");
	list.add("mary");
	int i;
	System.out.println(list.get(1));
}
public void f1() {
// @SuppressWarnings({"rawtypes"})
	List list = newArrayList();
	list.add("jack");
	list.add("tom");
	list.add("mary");
// @SuppressWarnings({"unused"})
	int i;
	System.out.println(list.get(1));
	}
}
```

> 总结：
>
> 抑制编译器警告
>
> 警告即黄条，他不影响程序的运行
>
> 但是这个注解可以使这些黄条不显示
>
> 用法：注解后加（{这里写要以制的类型，多个类型的话，用逗号间隔}）
>
> 作用域与放置的位置有关（放方法上只抑制方法，放语句上只抑制语句）（通常都放类上面，或方法上面（简单省事嘛~）） 

> 补充：
>
> 1、@interface 表示一个注解类，不是接口
>
> 2、修饰注解的注解，称之为元注解。

### 3.3 JDK 的元 Annotation(元注解， 了解)

#### 3.3.1 基本介绍

​	JDK 的元 Annotation 用于修饰其他 Annotation

​	元注解： 本身作用不大，讲这个原因希望同学们，看源码时，可以知道他是干什么.

#### 3.3.2 元注解的种类 (使用不多，了解, 不用深入研究)

​	1）Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME

​	2）Target // 指定注解可以在哪些地方使用

​	3）Documented //指定该注解是否会在 javadoc 体现

​	4）Inherited //子类会继承父类注解

#### 3.3.3 @Retention 注解

说明：

​	只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:

@Retention 的三种值：

​	1）RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释

​	2）RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值

​	3）RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注解

#### 3.3.4 @Target

说明：

​	用于修饰 Annotation 定义，用于指定被修饰的 Annotation 能用于修饰哪些程序元素。

​	@Target 也包含一个名为 value 的成员变量。

#### 3.3.5 @Documented

说明：

​	@Documented:用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc工具提取成文档，即在生成文档时，可以看到该注解。

说明：

​	定义为 Documented 的注解必须设置 Retention 值为 RUNTIME。

#### 3.3.6 @Inherited 注解

说明：

​	被它修饰的 Annotation 将具有继承性如果某个类使用了被 @Inherited 修饰的 Annotation ,则其子类将自动具有该注解

说明：

​	实际应用中，使用较少，了解即可。



> 元注解：本身作用不大，讲这个原因希望同学们，看源码时，可以知道他是干什么的。

