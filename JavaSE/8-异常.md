# 八、异常

## 1、概念：

​	程序执行过程中发生的不正常的情况

## 2、处理方式：

### 2.1 try - catch - finally

> 捕获异常，自行处理方式

```java
try{
    //代码/可能有异常
}catch(Exception e){
    //捕获到异常
    //1、当异常发生时
    //2、系统将异常封装成Exception对象e,传递给catch
    //3、得到异常对象后，程序员，自己处理
    //注意，如果没有发生异常catch代码块不执行
}finally{
    //1.不管try代码块是否有异常发生，始终要执行finally
	//所以，通常将释放资源的代码，放在finally
}
```

> 可以没有finally

### 2.2 throws

> 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者是JVM

![](image\throw的运行机制.png)

> 如果没用try方法，程序默认使用 throws 方法
>
> （经典理解，踢皮球给上一级，直到最上级摆烂，又将皮球踢给程序员)



```java
public void f2() throws FileNotFoundException,NullPointerException,ArithmeticException;
```

以上为异常列表形式，即多个异常

## 3、异常情况（两大类）

### 3.1 Error（错误）

​	Java虚拟机无法解决的严重问题，这种情况是严重错误，程序会崩溃

### 3.2 Exception（异常）

​	其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。

#### 3.2.1 运行时异常

> 编译器检测不出来的异常，这类异常程序员应该尽量的去避免

> 运行时异常的默认处理机制为 throws ，程序不会报错

| 异常                           | 表示                   |
| ------------------------------ | ---------------------- |
| NullPointerException           | 空指针异常             |
| ArithmeticException            | 数学运算异常           |
| ArraylndexOutOfBoundsException | 数组下标越界异常       |
| ClassCastException             | 类型转换异常           |
| NumberFormatException          | 数字格式不正确异常［］ |

#### 3.2.2 编译时异常

> 必须要处理的异常
>
> 程序会检测出来，要求程序员必须处理

| 异常                      | 表示                               |
| ------------------------- | ---------------------------------- |
| SQLException              | 操作数据库时，查询表可能发生异常   |
| IOException               | 操作文件时，发生的异常             |
| FileNotFoundException     | 当操作一个不存在的文件时，发生异常 |
| ClassNotFoundException    | 加载类，而该类不存在时，异常       |
| EOFException              | 操作文件，到文件末尾，发生异常     |
| IllegalArguementException | 参数异常                           |

​	如果一个方法中用 throws 抛出了一个编译异常，要求调用这个方法的成员，必须明确的标一个 throws 来将异常抛出，否则会报错

​	(运行异常默认可以用throws。而编译异常不行)

## 4、细节：

### 4.1 try - catch

#### 4.1.1 异常发生时

不会执行 try 中的代码块，而是直接进入到 catch 方法体中

#### 4.1.2 没有异常时

顺序执行 try 代码块，不执行 catch 代码块，如有 finally 方法，则 finally 方法始终要执行

#### 4.1.3 有多个异常时

可以有多个catch语句，捕获不同的异常（进行不同的业务处理），但要求父类异常在后，子类异常在前。

比如(Exception在后，NullPointerException在前，如果发生异常，只会匹配一个catch）

#### 4.1.4 不捕获异常

可以进行 try 和 finally 搭配使用(不要catch)，这种方法相当于不捕获异常，因此程序会直接崩掉，但是 finally 始终执行。

#### 4.1.5  try-catch-finally 执行顺序小结

1）如果没有出现异常，则执行 try 块中所有语句，不执行 catch 块中语句，如果有 finally ,最后还需要执行 finally 里面的语句

2）如果出现异常，则 try 块中异常发生后， try 块剩下的语句不再执行。将执行 catch 块中的语句，如果有 finally ,最后还需要执行 finally 里面的语句

#### 4.1.6 return情况

1）在 catch 块中有 return 而 finally 块中没有 return 时，catch 中 return 的返回值会被一个临时变量保存起来，在执行完 finally 方法后，再将被临时变量保存起来的值进行返回

2）在 catch 和 finally 两个方法块中同时都有 return 时，会执行 finally 中的 return 方法

3）总结：finally 块中有 return 时直接执行 finally 块中的 return 方法， finally 块中没有 return 时，catch 块中的 return 的返回值会被一个临时变量保存起来，在执行完 finally 方法后，再将被临时变量保存起来的值进行返回

### 4.2 throws细节：

1）子类重写父类的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类型

2）在 throws 过程中，有 try - catch 就相当于处理异常，就可以不必 throws

## 5、自定义异常：

概念：异常种类中没有的，需要程序员自己去定义的异常

### 5.1 自定义方法

> 需要自定义一个异常类，并继承编译异常(Exception)或运行异常(RuntimeException)

```java
class AgeException extends RuntimeException{
	public AgeException(String message){
    super(message);
}
```

> 大多数情况**默认继承运行异常**
>
> **好处：能默认调用throws方法**

 ## 6、throws和throw的区别

|        |           意义           |    位置    | 后面跟的东西 |
| :----: | :----------------------: | :--------: | :----------: |
| throws |    异常处理的一种方式    | 方法声明处 |   异常类型   |
| throw  | 手动生成异常对象的关键字 |  方法体中  |   异常对象   |

 ## 7、异常体系图：【！！重要】

   ![](image\异常体系图.png)