[TOC]



# 引子：认识Linux

## 1、Linux使用场景：

### 1.1、Linux开发

- JavaEE
- 大数据
- Python
- PHP
- c / c++
- go

### 1.2、Linux运维

​	Linux运维工程师，主要做：

- 服务器的规划
- 调试和优化
- 系统监控
- 故障处理
- 数据的备份和恢复
- 日志的分析
- 服务器瘫痪的修复，并保证数据不会丢失

> 运维往往管理的不是一台Linux，而是一个Linux集群

### 1.3、Linux嵌入式

​	Linux嵌入式工程师，简单了解即可

- 需要熟练掌握Linux下各种驱动的开发，需要在嵌入式的程序中进行开发
- 大部分使用 c / c++

## 2、Linux应用领域：

### 2.1、个人桌面领域

​	此领域是传统Linux应用薄弱的环节，近些年来随着ubuntu、fedora[fi'db:ra]等优秀桌面环境的兴起，Linux在个人桌面领域的占有率在逐渐的提高。

### 2.2、服务器领域

​	Linux在**服务器领域**的应用是最强的。

​	**Linux免费、稳定、高效**等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛 (c / c++ / php / java / python/go )

### 2.3、嵌入式领域

​	Linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行**软件裁剪**，内核最小可以达到几百**KB**等特点，使其近些年来在**嵌入式领域**的应用得到非常大的提高

​	主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后在**物联网中应用会更加广泛。**

# 一、Linux入门

## 1、认识Linux

### 1.1、概述

1. Linux读法，不下十种，不固定

2. Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发己经得到业界的认可，目前很多企业级的项目(c/c++/php/python/java/go)都会部署到Linux/unix系统上。

3. 常见的操作系统(windows、IOS、Android、MacOS、Linux、Unix)

4. Linux吉祥物：企鹅 ，名字为：Tux

5. Linux之父：Linus Torvalds

   - Git创作者
   - 世界著名黑客

6. Linux主要的发行版：

   - **Ubuntu(乌班图)**
   - **RedHat(红帽)**
   - **CentOS**
   - Debain[蝶变]
   - Fedora
   - SuSE
   - OpenSUSE[示意图]

   > 发行版就是以Linux为内核，对Linux进行不同的包装，以达到不同的效果

### 1.2、Linux和Unix的关系

- Unix的由来

![](image\001.png)

- Linux的由来

![](image\002.png)

- Linux和Unix的关系

![](image\003.png)

# 二、VM和Linux的安装

## 1、基本说明

​	学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习

1. 先安装virtual machine 15.5
2. 再安装Linux(CentOS7.6/centOS8.1)
3. 原理示意图：

![](image\004.png)

## 2、vmware下载

- 官方地址：https://www.vnware.com/cn.html

- 其它地址：https://www.nocmd.com/windows/740.html

> 版本不限，基本没有影响

### 2.1、VM安装步骤

去BIOS里修改设置，开启虚拟化设备支特(f2,10)

安装虚拟机软件(vm16.2.3)

> 如果正常安装没有问题那就这样即可
>
> 如果有问题就需要：
>
> ​	1、在BIOS开启CPU虚拟化支特(自行百度)
>
> ​	2、再安装
>
> **注**：win11只能装VM虚拟机版本16的，15的会报不兼容的错误

## 3、下载Centos

- CentOS-7-x86_64-DVD-1810.iso CentOS 7.6 DVD 版 4G (目前主流的生产环境)

​			 http://mirrors.163.com/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso 

- CentOS-8.1.1911-x86_64-dvd1.iso CentOS 8.1 DVD 版 8G (未来的主流.)

​			https://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso

#### 3.1、Centos安装步骤：

##### 	a>创建虚拟机

![](image\005.png)

![](image\006.png)	

![](image\007.png)

​	因为我们安装的是Centos7.6的系统，本身就是红帽的一个分支，所以我们这里选择红帽的操作系统

![](image\008.png)

![](image\009.png)

![](image\010.png)

![](image\011.png)

![](image\012.png)

自此创建虚拟机完成，这个时候的虚拟机还是不能使用的，需要我们手动改一下CD/DVD的设置才行



##### b>开始安装系统(CentOS7.6)的步骤

​	提示生成复杂密码：https:/suijimimashengcheng.51240.com/

​	挂载Centos7.6系统

![](image\013.png)

​	开启虚拟机

![](image\014.png)

![015](image\015.png)

![016](image\016.png)

![017](image\017.png)

![018](image\018.png)

![019](image\019.png)

![020](image\020.png)

![021](image\021.png)

![022](image\022.png)

![023](image\023.png)

![024](image\024.png)

![025](image\025.png)

![026](image\026.png)

![027](image\027.png)

![028](image\028.png)

![029](image\029.png)

![030](image\030.png)

![031](image\031.png)

![032](image\032.png)

![033](image\033.png)

![034](image\034.png)

![035](image\035.png)

![036](image\036.png)

![037](image\037.png)

![038](image\038.png)

![039](image\039.png)

![040](image\040.png)

![041](image\041.png)

至此，Centos系统安装成功

##### 	c>CentOS安装难点-网络连接方式理解

​	网络连接三种模式

- 桥接模式：

  ​	虚拟系统可以和外部系统通讯，但是容易造成IP冲突

- NAT模式：

  ​	网络地址转换模式，虚拟系统可以和外部系统通讯，不造成IP冲突

- 主机模式：

  ​	独立的系统，不和外界发生冲突 

## 4、虚拟机克隆

​	如果你已经安装了一台山x操作系统，你还想再更多的，老韩提示大家：没有必要再重新安装，你只需要克隆就可以

- 方式1，直接拷贝一份安装好的虚拟机文件
- 方式2，使用vmware的克隆操作，注意，克隆时，需要先关闭linux系统

## 5、虚拟机快照

​	如果你在使用虚拟机系练的时候（比如Linux)，你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware也提供了这样的功能，就叫快照管理。

> 类似于系统还原点

## 6、虚拟机的迁移和删除

​	我在前面讲过，虚拟系统安装好了，它的本质就是文件放在文件夹的。因此虚拟系统的迁移很方便，你可以把安装好的虚拟系统这个**文件夹整体拷贝或者剪切**到另外位置使用。删除也很简单，用**vmware进行移除**，再点击菜单 -> 从磁盘删除即可，或者**直接手动删除虚拟系统对应的文件夹**即可。

## 7、安装VMtools

### 1、介绍

- vmtools安装后，可以让我们在windows下更好的管理vm虚拟机

- 可以设置windows:和centos的共享文件夹

### 2、具体步骤

1. 进入centos

2. 点击vm菜单的->install vmware tools

3. centos会出现一个Vm的安装包，XX.tar.gz

4. 拷贝到/opt

   > cd/opt[进入到opt目录]

5. 使用解压命令tar,得到一个安装文件

   > tar -zxvf xx.tar.gz
   >
   > Tab键自动补全

6. 进入该vm解压的目录，/opt目录下

7. 安装./vmware-install.pl

8. 全部使用默认设置即可，就可以安装成功

9. 注意：安装vmtools需要有gcc(开发环境)

   > 查看gcc：gcc -v，有就会提示相关版本，没有就会报错
   >
   > 补充：ls查看当前文件夹下的文件

### 3、设置共享文件夹

#### a>基本介绍

​	为了方便，可以设置一个共享文件夹，比如d:/myshare

#### b>具体步骤

1. 菜单->vm->setting,如图设置即可，注意：设置选项为always enable，这样可以读写了

2. windows和centos可共享d:/myshare目录，可以读写文件了

3. 共享文件夹在centos的其他位置//mnt/hgfs/下

![](image\042.png)

![043](image\043.png)

> 这一步需要先在母机上创建一个给VMtools共享的文件夹

#### c>注意事项和细节说明

- windows和contos就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用远程方式完成的

# 四、Linux的目录结构

### 1、基本介绍

- Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。

- 深刻理解Linux树状文件目录是非常重要的

- 记住一句经典的话：**在Linux世界里，一切皆文件(！！)**

### 2、具体的目录结构

> 不用背，但是要有影响印象

- /bin**[常用]**(/usr/bin、/usr/local/bin)

是Binary的缩写，这个目录存放着最经常使用的命令

- /sbin(/usr/sbin 、/usr/local/sbin)

s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。

- /home**[常用]**

存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名

- /root**[常用]**

该目录为系统管理员，也称作超级权限者的用户主目录

- /Iib

系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库

- /lost+found

这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件

- /etc**[常用]**

所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库my.conf

- /usr**[常用]**

这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。

- /boot**[常用]**

存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件

- /proc<u>**[不能动]**</u>

这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息

- /srv**<u>[不能动]</u>**

service缩写，该目录存放一些服务启动之后需要提取的数据

- /sys**<u>[不能动]</u>**

这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs =》【别动】

- /tmp

这个目录是用来存放一些临时文件的

- /dev

类似于windows的设备管理器，把所有的硬件用文件的形式存储

- /media[常用]

linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下

- /mnt[常用]

系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上然后进入该目录就可以查看里的内容了。例如：共享文件目录d:/myshare

- /opt

这是给主机额外安装软件所存放的目录。如安装ORACLE数据库就可放到该目录下。默认为空

- /usr/local**[常用]**

这是另一个给主机额外安装软件所安装的目录(软件安装的目标目录)。一般是通过编译源码方式安装的程序

- /var**[常用]**

这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件

- /selinux [security-enhanced linux]

SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置(需要开启安全设置才能看到，没有开启安全模式的话，是不会在根目录下生成相应的文件的)

# 五、远程登录Linux服务器

## 1、基本介绍

### a> 为什么需要远程登录Linux

说明：公司开发时候，具体的应用场景是这样的：

1)linux服务器是开发小组共享

2)正式上线的项目是运行在公网

3)因此程序员需要远程登录到Liux进行项目管理或者开发

4)远程登录客户端有Xshell6，Xftp6，我们学习使用Xshell和Xftp6，其它的远程工具大同小异

### b> Xshell：远程登录

1）说明：Xshell是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。

2）Xshell是一个强大的安全终端模拟软件，它支持SSH1,SSH2,以及Microsoft Windows平台的TELNET协议。

3）Xshelli可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的

#### 下载

地址：https://www.netsarang.com/en/free-for-home-school/

#### 使用

使用之前需要先查看虚拟机IP的地址和主机IP的地址

windows查询IP的指令为ipconfig，Linux查询IP的指令为ifconfig

查到地址之后，需要使用ping + IP地址在终端中使用一下，能联通说明没有问题，可以开始使用Xshell了

> Xshell使用也简单，只需要保证新建会话的IP地址不出错误即可

#### BUG

不能ping通，则说明出问题了，解决方法如下：

1.  主机和虚拟机互ping测试，如果发现虚拟机能ping通主机，但是主机ping不通虚拟机，则进入下一步
2. 查看网络连接中是否有虚拟机的网络连接，如果没有，则进入下一步
3. 进入VM虚拟机界面 --> 找到位于上方的 **[编辑]** 键，并点击 --> 找到 **[虚拟网络编辑器]**，并点击 --> 已**root管理员**的身份，找到**[更改设置]**键，并点击， --> 找到**[将主机虚拟适配器连接到此网络]**键，并将其勾选上，并点击确定，如果加载时间过长，但就是不成功，并且加载完成后，还是没有在 **[网络连接]** 中找到VM虚拟机的网络连接项，并且再次进入 **[虚拟网络编辑器]**时，发现本来已经勾选上了的 **[将主机虚拟适配器连接到此网络]** 键还是没有勾选上时，进入下一步
4. 问题的核心就在于第三步，而造成第三步的原因又是：**注册表项没有清理干净，造成了干扰，需要下载软件进行彻底清理再重新操作一遍**，就没有问题了，并且可以找到VMnet8了。
   1. 下载ccleaner，地址为：https://www.ccleaner.com/
   2. 找到CCleaner界面左侧的 **[注册表]** 一栏
   3. 进入 **[注册表]** 界面之后，点击左下角的 **[扫描问题]**，等待扫描完成后，点击 **[查看选定问题]**，再点击 **[修复所有选定的问题]**，即可 

### c>Xftp：文件上传和下载

1）介绍：

是一个基于windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，windows用户能安全地在UNIX/Linux和Windows PC之间传输文件。

2）安装-配置-使用

跟Xshell配套下载即可

使用上与Xshell基本一样

细节问题：中文乱码问题，再属性窗口的选项栏中，设置编码即可

# 六、Vi和Vim

## 1、基本介绍

​	Linux 系统会内置 vi 文本编辑器

​	Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程

的功能特别丰富，在程序员中被广泛使用。

## 2、三种模式

### a>正常模式

​	以Vim打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】或

【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据。

### b>插入模式

​	按下【i，I，o，O，a，A，r，R】等任何一个字母之后才会进入编辑模式，一般来说按i即可。

### c>命令行模式

​	先输入【Esc】，然后再输入【  ：】，进入命令行模式，在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开Vim、显示行号等的动作则是在此模式中达成的！

> 指令【wq】，表示写入并保存

## 3、vi和vim的基本使用

​	各种模式间的切换：

- 命令行模式下：vim + 文件名，即可进入普通模式
- 普通模式下：输入 i , a , 即可进入编辑模式，输入【:】【/】即可进入命令模式
- 再普通模式和命令模式下：输入【Esc】即可回退至普通模式
- 在命令模式下：输入【：wq】表示保存并退出，输入【：q】表示退出，输入【：q！】表示强制退出，不保存 

## 4、快捷键

1. **拷贝当前行：yy**，拷贝当前行向下的5行：5yy，并**粘贴（输入p）**。
2. **删除当前行：dd**，删除当前行向下的5行：5dd
3. **在文件中查找某个单词** [命令行下：**/关键字**，回车 查找，**输入 n 就是查找下一个**]
4. **设置文件的行号**，**取消文件的行号**.[命令行下**：set nu和：set nonu**]
5. **编辑/etc/profile文件**，**在一般模式下**，使用快捷键到该文档的**最末行[G]和最首行[gg]**
6. 在一个文件中输入"hello”，**在一般模式下**，然后又**撤销**这个动作：**u**
7. 编辑/etc/profile文件，**在一般模式下**，并**将光标移动到：20行，再输入shift+g**
8. 更多的看整理的文档

## 5、键盘图

![](image\Vi和Vim键盘图.png)

# 七、开机、重启、用户登录注销

## 1、基本介绍

|          指令          |           效果           |
| :--------------------: | :----------------------: |
| shutdown	-h	now  |       立该进行关机       |
| shudown	-h		1 | "hello,,1分钟后会关机了” |
| shutdown	-r	now  |    现在重新启动计算机    |
|          halt          |   关机，作用和上面一样   |
|         reboot         |    现在重新启动计算机    |
|          sync          |  把内存的数据同步到磁盘  |

> 细节：
>
> 不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中
>
> 目前的shutdown/reboot/halt等命令均已经在关机前进行了sync,老韩提醒：小u心驶得万年船

## 2、用户登录和注销

### a>基本介绍

1. 登绿时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用【su - 用户名】命令来切换成系统管理员身份.
2. 在提示符下输入 logout 即可注销用户

### b>使用细节

1. logout 注销指令在图形运行级别无效，在 运行级别3下有效
2. 运行级别这个概念，后面给大家介绍

# 八、用户管理

> 基本介绍：
>
> Liux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统

## 1、添加用户

### a>基本语法

useradd	+	用户名

### b>细节说明

1. 默认新创建的用户的家目录在 【/home/用户名】 下，在用改用户登录时，会自动切换到该目录下
2. 当创建用户成功后，会自动的创建和用户同名的家目录
3. 也可以通过【useradd - d】指定目录，新的用户名，给新创建的用户指定家目录

## 2、指定/修改密码

### a>基本语法

passwd	+	用户名

> 补充：指令【pwd】，显示当前用户所在目录

## 3、删除用户

### a>基本语法

userdel	+	用户名

### b>两种删除情况

1）删除用户，保留该用户所在的家目录，指令：【userdel 	+	用户名】

2）删除用户，并且删除用户所在的家目录，指令：【userdel	+	-r	+	用户名】

### c>细节

一般情况下都建议**保留家目录**

## 4、查询用户信息

### a>基本语法

id	+ 	用户名

### b>细节

当用户不存在时，返回无此用户

## 5、切换用户

### a>基本语法

su - 用户名

### b>介绍

在操作Linux中，如果当前用户的权限不够，可以通过su - 指令，切换到高权限用户，比如root

### c>细节

1. 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。
2. 当需要返回到原来用户时，使用exit/logout指令

## 6、查看当前用户

### a>基本语法

whoami	/	who am i

### b>细节

显示的是第一次登录的用户信息，而不是中途切换了的用户信息

## 7、用户组

### a>介绍

类似于角色，系统可以对有共性 / 权限的多个用户进行统一的管理

### b>新增组

指令：【groupadd	+	组名】

### c>删除组

指令：【groupdel	+	组名】

### d>增加用户时直接加上组

指令：【useradd	+	-g	+	用户组	+	用户名】

### e>修改用户的组

指令：【usermod	+	-g	+	用户组	+	用户名】

### f>细节

1. 如果创建用户时，没有给用户分配组，那么默认是创建一个跟用户同名的组，然后将该用户放入这个组中

### g>用户和组相关文件

- /etc/passwd	文件

用户（user)的配置文件，记录用户的各种信息

每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell

- /etc/shadow	文件

口令的配置文件

每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志

- /etc/group	文件

组(group)的配置文件，记录Linux包含的组的信息

每行含义：组名：口令：组标识号：组内用户列表

# 九、实用指令

## 1、指定运行级别

### a>基本介绍

运行级别说明：

0：关机

1：单用户【找回丢失密码】

2：多用户状态没有网络服务

3：多用户状态有网络服务

4：系统未使用保留给用户

5：图形界面

6：系统重启

常用运行级别是3和5，也可以指定默认运行级别

### b>指令

init	+	运行级别

### c>说明

> 在centos7以前，/etc/inittab文件中，进行设置

centos7之后，进行了简化，如下：

指令：【multi-user.target】：analogous to runlevel 3	（表示运行级别3）

指令：【graphical.target】：analogous to runlevel 5	（表示运行级别5）

**查看默认运行级别：**

​	`systemctl get-default`

**修改默认运行级别：**

​	`systemctl set-default 简化的表示运行级别的指令`

## 2、找回root密码

### a>流程

1. 首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。
2. 进入编辑界面，使用键盘上的上下键把光标往下移动，找到以“Linux16”开头内容所在的行数”，在行的最后面输入：`init=/bin/sh`
3. 接着，输入完成后，直接按快捷键：`Ctrl+x` 进入单用户模式。
4. 接着，在光标闪烁的位置中输入：`mount -o remount,rw /`(注意：各个单词间有空格，rw与"/"之间也有一个空格)，完成后按键盘的回车键(Enter)。【这个指令表示的是：修改读写权限】
5. 在新的一行最后面输入：`passwd`，完成后按键盘的回车键(Enter)。输入密码，**然后再次确认密码**即可（韩顺平提示：密码长度最好8位以上，但不是必须的)，密码修改成功后，会显示`passwd...`的样式，说明密码修改成功
6. 接着，在鼠标闪烁的位置中（最后一行中）输入：`touch /.autorelabel`(注意：`touch` 与 `/` 之间有一个空格)，完成后按键盘的回车键(Enter)
7. 继续在光标闪烁的位置中，输入：`exec /sbin/init`(注意：`exec` 与 `/`之间有一个空格)，完成后按键盘的回车键(Enter)，等待系统自动修改密码（韩顺平提示：这个过程时间可能有点长，耐心等待），完成后，系统会自动重启，**新的密码生效了**

## 3、帮助指令

#### 	a> man 获得帮助信息

​	基本语法：【man	[命令或配置文件]】(功能：获得帮助信息)

> 补充：
>
> 1、隐藏文件是以【.】开头
>
> 2、指令`ls -a`表示显示包括隐藏文件在内的所有文件
>
> 3、指令`ls -al`或`ls -la`表示以单列的形式列出所有的文件，包括隐藏文件，`ls -l`
>
> 4、指令`ls -l`表示以单列的形式列出显示的文件
>
> 5、指令`ls /目录`表示指定显示某一个目录下的所有显示文件

#### 	b> help指令

​	基本语法：【help + 命令】（功能：获得shell内置命令的帮助信息）

#### 	c> 百度一下

## 4、文件目录类

### 1>	pwd指令(绝对路径)

​	基本语法：pwd （功能：显示当前工作目录的绝对路径）

### 2>	ls指令(查看)

​	基本语法：ls	[选项]（目录或是文件）

​	常用选项：

​	-a：显示当前目录下的所有文件和目录，包括隐藏的

​	-l：以列表的方式显示信息

​	-h：以更加适合人查阅的方式显示（占用内存大小）

> 使用	ls -l	查到的文件的占用大小是以字节的形式显示的，人查阅时，看起来非常的不舒服，所以可以使用	ls -lh	指令，这样，查到的文件的占用大小就是以k，M，G的形式显示的	

### 3>	cd指令(切换)

​	基本语法：cd	[参数]（功能：切换到指定目录）

​	理解：可以定位绝对路径和相对路径

​	cd~ 或者 cd ：表示回到自己的家目录

​	cd .. ：表示回到当前目录的上一级目录

### 4>	mkdir指令(创建目录)

​	基本语法：mkdir	[选项]（要创建的目录）	（功能：创建目录）

​	常用选项：

​	-p：创建多级目录

### 5>	rmdir指令(删除目录)

​	基本语法：rmdir	[选项]（要删除的空目录）	（功能：删除空目录）

​	细节：

​	rmdir删除的是空目录，如果目录下有内容是无法删除的

​	如果想要删除非空目录，需要使用指令：【rm	-rf	要删除的目录】

### 6>	touch指令(创建文件)

​	基本语法：touch	文件名称	（功能：创建一个空文件）

### 7>	cp指令(复制文件)

​	基本语法：cp	（-r）	[选项]（选择的文件）	+【source	dest】（指定位置）	（功能：拷贝文件到指定目录）

​	常用选项：

​	-r：递归复制整个文件夹

> 细节：
>
> 指令【\cp】：表示强制覆盖不提示，就是在cp前面加一个【\】，其他照旧

### 8>	rm指令(删除)

​	基本语法：rm	（-r/-f/-rf）	[选项]（要删除的文件或目录）

​	常用选项：

​	-r：递归删除整个文件夹

​	-f：强制删除不提示

### 9>	mv指令(重命名和移动)

​	基本语法：

​	1、	mv	+	老文件名	+	新文件名	（功能：重命名）

​	2、	mv	+	当前文件（使用的是相对路径的方法）	+	新目录名	（功能：移动文件）

​	3、	mv	+	老文件名	+	目录名+新文件名（中间没有间隔）	（功能：组合，移动并重命名）

> 细节：
>
> 移动目录同语法1，将老文件名改为目录名即可

### 10>	cat指令(只读)

​	基本语法：cat	（-n）	[选项]（要查看的文件）（功能：查看文件内容）

​	常用选项

​	-n：显示行号

> 细节：
>
> ​	cat只能浏览文件，不能修改文件，为了方便浏览，一般会带上**管道命令**：【|more】

### 11>	more指令(查看)

​	基本语法：more	要查看的文件

> 介绍：
>
> ​	more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键（交互的指令），详见操作说明

​	操作说明：

|     操作     |                功能说明                |
| :----------: | :------------------------------------: |
| 空格(space） |           代表向下翻【一页】           |
|    Enter     |           代表向下翻【一行】           |
|      q       | 代表立刻离开more，不再显示该文件内容。 |
|    Ctrl+F    |              向下滚动一屏              |
|    Ctrl+B    |               返回上一屏               |
|      =       |            输出当前行的行号            |
|      :f      |        输出文件名和当前行的行号        |

### 12>	less指令(查看)

​	基本语法：less	要看的文件

> 介绍：
>
> ​	Iess指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是
>
> 一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率

​	操作说明：

|    操作    |                     功能说明                     |
| :--------: | :----------------------------------------------: |
|   空白键   |                   向下翻动一页                   |
| [pagedown] |                   向下翻动一页                   |
|  [pageup]  |                   向上翻动一页                   |
|   /字串    | 向下搜寻『字串』的功能；n：向下查找；N：向上查找 |
|   ?字串    | 向上搜寻『字串』的功能；n：向上查找；N：向下查找 |
|     q      |                 离开less这个程序                 |

### 13>	echo指令【特殊】(输出)

​	基本语法：echo	[选项]（输出内容）	（功能：输出内容到控制台）

​	特殊案例：

​	1、输出环境变量：`$PATH或$HOSTNAME的示例, echo $PATH`

​	2、输出内容到控制台：`echo "hello,world!"`，就会将双引号中的内容输出到控制台

### 14>	head指令【特殊】(查看头)

​	基本语法：

​	1、head	文件	（默认情况下，查看文件头10行内容）

​	2、head	-n	5	文件	（指定查看文件头5行内容，5可以是任意行数）

### 15>	tail指令(查看尾)

​	基本语法：

​	1、tail	文件	（功能：输出文件尾部内容，默认输出10行）

​	2、tail	-n	行数	文件	（自定义查看文件尾部不定数量的行数）

​	3、tail	-f	文件	（实时追踪该文档的所有更新）

> 补充：退出追踪查看的文件使用	ctrl + C

### 16>	>指令和>>指令(覆盖和追加)

​	介绍：【>】表示输出重定向，并会覆盖原文件内容，【>>】表示追加

​	基本语法：

​	1、ls	-l	>	文件	（功能：列表的内容写入文件中【覆盖写】）

​	2、ls	-al	>>	文件	（功能：列表的内容追加到文件的末尾）

​	3、cat	文件1	>	文件2	（功能：将文件1的内容覆盖到文件2）

​	4、echo	"内容"	>>	文件	（功能：将**输出的内容追加到文件的末尾**）

> 细节：
>
> 1、如果没有相应的文件会自动创建一个
>
> 2、补充指令：cal	，表示显示当前日历信息

### 17>	ln指令(快捷或软链接)

​	介绍：软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径

​	基本语法：

​	ln	-s	[原文件或目录]	[软链接名]	（功能：给原文件创建一个软链接）

> 细节：
>
> ​	当我们使用pwd（绝对路径）指令查看目录时，仍然看到的是软链接所在目录

### 18>	history指令

​	介绍：查看已经执行过了的历史命令，也可以执行历史命令

​	基本语法：

​	1、history	（功能：查看所有历史命令）

​	2、history	行数	（功能：查看最近行数的历史命令）

​	3、！行数	（功能：执行历史行数为该行数的指令）

## 5、时间日期类

### 1>	date指令(显示时间)

​	介绍：显示当前日期

​	基本语法：

​	1、date	（功能：显示当前时间）

​	2、date	+	%Y	（功能：显示当前年份）

​	3、date	+	%m	（功能：显示当前月份）

​	4、date	+	%d	（功能：显示当前是哪一天）

​	5、`date	"+%Y-%m-%d %H:%M:%S"`	（功能：显示年月日时分秒）

### 2>	date指令(设置时间)

​	基本语法：

​	date	-s	字符串时间

​	示例：`date -s "年月日时分秒"`

### 3>	cal指令(查看日历)

​	基本语法：

​	1、cal	（功能：默认显示本月月历）

​	2、cal	[选项]（年份）	（功能：显示输入年份所在的所有日历）

## 6、搜索查找类

### 1>	find指令(查找)

​	介绍：find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端，

​	基本语法：find	[搜索范围]	[选项]

​	选项说明：

|      选项       |               功能               |
| :-------------: | :------------------------------: |
| -name<查询方式> | 按照指定的文件名查找模式查找文件 |
|  -user<用户名>  |    查找属于指定用户名所有文件    |
| -size<文件大小> |    按照指定的文件大小查找文件    |

> 补充：
>
> ​	1、size指定大小时，数字前面为+，表示找大于该数的，为-，找小于该数的，什么都不加，表示找等于该数的，
>
> ​	2、size指定大小时，数字的单位可以为k，M，G

### 2>	locate指令(快速定位)

介绍：

​	locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍

历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻



基本语法：

​	locate	搜索文件



特别说明：

​	由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。

### 3>	which指令(查询指令位置)

介绍：

​	可以查看某个指令在哪个目录下



基本语法：

​	which	指令

### 4>	grep指令和管道符号 | (过滤查找)

介绍：

​	grep过滤查找，管道符，“|"，表示将前一个命令的处理结果输出传递给后面的命令处理。



基本语法：

​	grep	[选项]	查找内容	原文件	

常用选项：

| 选项 |       功能       |
| :--: | :--------------: |
|  -n  | 显示匹配行和行号 |
|  -i  |  忽略字母大小写  |



搭配应用实例：

​	1、做过滤器搭配用：`cat 文件名	| grep "查找内容"`

​	2、单独使用：`grep -n "保留内容" 文件`

## 7、压缩和解压类

### 1>	gzip/gunzip指令

介绍：

​	gzip用于压缩文件，gunzip用于解压的



基本语法：

​	1）gzip	文件	（功能：压缩文件，只能将文件压缩为`*.gz`文件）

​	2）gunzip	文件.gz	（功能：解压缩文件命令）

### 2>	zip/unzip指令

介绍：

​	zip用于压缩文件，unzip用于解压，这个在项目打包发布中很有用



基本语法：

​	1）zip	[选项]	XXX.zip	将要压缩的内容	（功能描述：压缩文件和目录的命令）

​	2）unzip	[选项]	XXX.zip	（功能：解压缩文件）



zip常用选项

​	-r：递归压缩，及压缩目录



unzip的常用选项

​	-d<目录>：指定解压后文件的存放目录

### 3>	tar指令

介绍：

​	tar指令是打包指令，最后打包后的文件是`.tar.gz`的文件



基本语法：

​	tar	[选项]	XXX.tar.gz	打包的内容	（功能：打包目录，压缩后的文件格式`.tar.gz`）

选项说明：

| 选项 |        功能        |
| :--: | :----------------: |
|  -c  | 产生`.tar`打包文件 |
|  -v  |    显示详细信息    |
|  -f  | 指定压缩后的文件名 |
|  -z  |    打包同时压缩    |
|  -x  |   解包`.tar`文件   |

> 补充：
>
> ​	-C	<目录>	（功能：指定文件解压后的位置）用在【打包内容】的后面

# 十、组管理和权限管理

## 1、组的基本介绍

​	在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。

## 2、文件、目录 所有者介绍

​	一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。

### a>查看文件的所有者

​	指令：ls	-ahl

### b>修改文件所有者

​	指令：chown	用户名	文件名

## 3、组的创建

基本指令：

​	groupadd	组名

### a>查看文件/目录所在组

基本指令：

​	ls	-ahl

### b>修改文件所在组

基本指令：

​	chgrp	组名	文件名

## 4、其他组

介绍：除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组

## 5、改变用户所在组

​	在添动加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组

### a>改变用户所在组

1、usermod	-g	新组名	用户名

2、usermod	-d	目录名	用户名	改变该用户登录的初始目录	（功能：修改用户登录的初始目录）

> 特别备注：用户需要有进入到新目录的权限

## 6、权限

### a>基本介绍

`ls -l`指令	中显示的内容如下：

​	`-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc`



**0-9位说明**：

1. 第0位确定文件类型(`d,~,l,c,b`)

> `l` 是链接，相当于windows的快捷方式
>
> `d` 是目录，相当于windows的文件夹
>
> `c` 是**字符设备**文件，鼠标，键盘
>
> `b` 是**块设备**，比如硬盘
>
> `-`表示一个普通文件

2. 第1-3位确定**所有者**（该文件的所有者）拥有该文件的权限

3. 第4-6位确定**所属组**（同用户组的）拥有该文件的权限

4. 第7-9位确定**其他组或用户**拥有该文件的权限

### b>rwx权限详解(1-3位)

- **rwx作用到文件**
  - [`r`]代表**可读**（read）：可以读取，查看
  - [`w`]代表**可写**（write）：可以修改，但是**不代表可以删除该文件**，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。
  - [`x`]代表**可执行**（execute）：可以被执行
- **rwx作用到目录**
  - [`r`]代表**可读**（read）：可以读取，**Is查看目录内容**
  - [`w`]代表**可写**（write）：可以修改，对**目录内创建+删除+重命名目录**
  - [`x`]代表**可执行**（execute）：**可以进入该目录**

> 补充：
>
> ​	可用数字表示为：`r = 4,w = 2,x = 1` 因此`rwx = 4 + 2 + 1 = 7`

### c>其他说明

​		案例：`-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc`

**说明：**

`1`：**文件：硬连接数或目录	目录：子目录数+文件数（如果是目录就表示这个数量）**

`root`：**用户**

`root`：**组**

`1213`：**文件大小（按字节显示），如果是文件夹，显示4096字节**

`Feb 2 09:39`：**最后修改日期**

`abc`：**文件名**

### d>修改权限-chmod

- **基本说明**

  通过chmod指令，可以**修改文件或者目录的权限**。

- **第一种方式：`+、-、=`变更权限：**

  ​	**u：所有者	g：所有组	o：其他人	a：所有人	(u、g、o的总和)**

  - `chmod u=rwx,g=rx,o=x	文件/目录名`	（功能：给选项）
  - `chmod	o+w	文件/目录名` 	（功能：单独给其他人写的权限）
  - `chmod	a-x	文件/目录名`	（功能：将所有人的执行权限去掉）

- **案列：**

  1）给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。

  `chmod u=rwx,g=rx,o=rx abc`

  2)给abc文件的所有者除去执行的权限，增加组写的权限

   `chmod u-x,g+w abc`

  3)给abc文件的所有用户添加读的权限

  ​	`chmod a+r abc`

- **第二种方式：通过数字变更权限**

  ![](image\权限对应数字.png)

  `r=4	w=2	x=1	rwx = 4 + 2 + 1 = 7`

  `chmod u=rwx,g=rx,o=x 文件目录名`

  相当于：	`chmod 751 文件目录名`

  √案例演示

  要求：将/home/abc.txt文件的权限修改成rwxr-xr-X,使用给数字的方式实现：

  实现：`chmod 755 /home/abc.txt`	（第一个数字表示给用户的权限，第二个表示给用户所在组的权限，第三个表示给其他人的权限）

### e>修改文件所有者-chown

​	**基本介绍：**

​	`chown 新所有者 文件/目录 ` 	（功能：**改变所有者**）

​	`chowm 新所有者:新组 文件/目录` 	（功能：**同时改变所有者和所在的组**）

​	`-R` ：**如果是目录，则使其下所有子文件或目录递归生效**

​	

​	**案例演示：**

1）请将/home/abc.txt文件的所有者修改成tom

​	`chown tom /home/abc.txt`

2）请将/home/test目录下所有的文件和目录的所有者都修改成tom

​	`chown -R tom /home/test`

### f>修改文件/目录所在的组-chgrp

​	**基本介绍**：

​	`chgrp 新组 文件/目录`	（功能：**改变所有组**）

​	**案列演示**：

1）请将`/home/abc.txt`文件的所在组修改成shaolin(少林)

​	`chgrp shaolin /home/abc.txt`

2）请将`/home/kkk`目录下所有的文件和目录的所在组都修改成shaolin(少林)

​	`chgrp -R shaolin /home/kkk`



> **强调**：
>
> **rwx作用到目录**
>
> [`r`]代表**可读**（read）：可以读取，**Is查看目录内容**
>
> [`w`]代表**可写**（write）：可以修改，对**目录内创建+删除+重命名目录**
>
> [`x`]代表**可执行**（execute）：**可以进入该目录**



# 十一、定时任务调度

## 1、crond 任务调度

### 1）概念简介

**crontab 进行 定时任务的设置**

**任务调度：是指系统在某个时间执行的特定的命令或程序。**

**任务调度分类**：1.系统工作：有些重要的工作**必须周而复始地执行**。如病毒扫描等

**个别用户工作**：个别用户可能希望执行某些程序，比如对mysql数据库的备份。

### 2）基本语法

​	`crontab [选项]`

**常用选项：**

| 选项 |             功能              |
| :--: | :---------------------------: |
| `-e` |      编辑crontab定时任务      |
| `-l` |        查询crontab任务        |
| `-r` | 删除用户当前所有的crontab任务 |

### 3）快速入门

设置任务调度文件：`/etc/crontab`

设置个人任务调度。执行`crontab -e`命令。

接着输入任务到调度文件

如：`*/1**** ls -l /etc/ > /tmp/to.txt`

意思说每小时的每分钟执行`ls -l /etc/ > /tmp/to.txt`命令

`*/1**** ls -l /etc/ > /tmp/to.txt`	**参数细节说明（5个占位符）**

|    项目    |         含义         |           范围            |
| :--------: | :------------------: | :-----------------------: |
| 第1个`"*"` | 一小时当中的第几分钟 |          `0-59`           |
| 第2个`"*"` |  一天当中的第几小时  |          `0-23`           |
| 第3个`"*"` |  一个月当中的第几天  |          `1-31`           |
| 第4个`"*"` |  一年当中的第几个月  |          `1-12`           |
| 第5个`"*"` |   一周当中的星期几   | `0-7`（0和7都表示星期日） |

### 4）特殊符号说明

| 特殊符号 |                             含义                             |
| :------: | :----------------------------------------------------------: |
|   `*`    | 代表任何时间。比如第一个`“*”`就代表一小时中每分钟都执行一次的意思。 |
|   `,`    | 代表不连续的时间。比如`“0 8,12,16 *** 命令”`，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |
|   `-`    | 代表连续的时间范围。比如`“0 5 * * 1-6命令”`，代表在周一到周六的凌晨5点0分执行命令 |
|  `*/n`   | 代表每隔多久执行一次。比如`“*/10 * * * * 命令”`，代表每隔10分钟就执行一遍命令 |

**特定时间执行任务案例：**

|        时间         |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
| `45 22 * * * 命令`  |                      在22点45分执行命令                      |
|  `0 17 * * 1 命令`  |                   在每周1的17点0分执行命令                   |
| `0 5 1,15 * * 命令` |               每月的1号和15号的5点0分执行命令                |
| `40 4 * * 1-5 命令` |              每个星期1至星期5的4点40分执行命令               |
| `*/10 4 * * * 命令` |            每天的凌晨4点，每隔10分钟执行一次命令             |
| `0 0 1,15 * 1 命令` | 每月1号和15号的星期1的0点0分执行命令。<br>**注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱** |

### 5）应用案例

**案例1：每隔1分钟，就将当前的日期信息，追加到`/tmp/mydate`文件中**

`*/1****date >>/tmp/mydate`

**案例2：每隔1分钟，将当前日期和日历都追加到`/home/mycal`文件中**

**步骤：**

(1)`vim/home/my.sh`写入内容`date >> /home/mycal`和`cal >> /home/mycal`

(2)给`my.sh`增加执行权限，`chmod u+x /home/my.sh`

(3)`crontab-e`增加`*/1**** /home/my.sh`

> 补充：
>
> 定时执行可以有两个方式，一个是直接写指令，另一个是写一个脚本，赋给脚本用户相应的调用权限，然后定时去调用这个脚本，这个脚本就是shell脚本，后缀`.sh`

**案例3：每天凌晨2：00将mysql数据库testdb，备份到文件中。**

提示：指令为`mysqldump -u root -p 密码 数据库 > home/db.bak`

步骤(1)`crontab -e`

步骤(2)`0 2 *** mysqldump -u root -proot testdb > /home/db.bak`

### 6）crond 相关指令

`crontab -r`：**终止任务调度。（删除/清空任务）**

`crontab -l`：**列出当前有那些任务调度**

`service crond restart`：**[重启任务调度]**

## 2、at定时任务

### 1）概念简介

**基本介绍**

1. at命令是**一次性定时计划任务**，at的守护进程atd会**以后台模式运行**，**检查作业队列来运行**。
2. 默认情况下，**atd守护进程每60秒检查作业队列**，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。
3. at命令是一次性定时计划任务，**执行完一个任务后不再执行此任务了**
4. 在使用at命令的时候，一定要**保证atd进程的启动**，可以使用相关指令来查看

> `ps -ef | grep atd` **可以检测atd是否在运行**

### 2）at命令格式

`at （[选项]） [时间]`

**Ctrl+D（两次） 结束at命令的输入**

**at命令选项：**

|      选项      |                           含义                           |
| :------------: | :------------------------------------------------------: |
|      `-m`      | 当指定的任务被完成后，将给用户发送邮件，即使没有标准输出 |
|      `-I`      |                        atq的别名                         |
|      `-d`      |                        atrm的别名                        |
|      `-v`      |                  显示任务将被执行的时间                  |
|      `-c`      |                 打印任务的内容到标准输出                 |
|      `-V`      |                       显示版本信息                       |
|   `-q<队列>`   |                      使用指定的队列                      |
|   `-f<文件>`   |          从指定文件读入任务而不是从标准输入读入          |
| `-t<时间参数>` |             以时间参数的形式提交要运行的任务             |

### 3）at时间定义

**at指定时间的方法：**

1. **接受在当天的`hh:mm`(小时：分钟)式的时间指定**。假如该时间已过去，那么就**放在第二天执行**。例如：`04:00`

2. 使用`midnight`（深夜），`noon`（中午），`teatime`（饮茶时间，一般是下午4点）等**比较摸糊的词语来指定时间**。

3. 采用**12小时计时制**，即在**时间后面加上AM（上午）或PM（下午）来说明是上午还是下午**。例如：12pm

4. **指定命令执行的具体日期**，指定格式为`month day（月日）`或`mm/dd/yy（月/日/年）`或`dd.mm.yy（日.月.年）`，指定的日期必须跟在指定时间的后面。例如：`04：00 2021-03-1`

5. **使用相对计时法**。指定格式为：`now + count time-units`，**now就是当前时间**，**time-units是时间单位**，**这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）**。**count是时间的数量**，几天，几小时。例如：`now + 5 minutes`

6. **直接使用today（今天）、tomorrow（明天）**来指定完成命令的时间。

### 4）应用案列

案例1：2天后的下午5点执行`/bin/ls /home`

1>`at 5pm + 2 days`

2>`/bin/ls /home（退出Ctrl+D两次）`

案例2：atq命令来查看系统中没有执行的工作任务

案例3：明天17点钟，输出时间到指定文件内比如`/root/date100.log`

1>`at 5pm tomorrow`

2>`date > /root/date100.log（退出）`

案例4：2分钟后，输出时间到指定文件内比如`/root/date200.log`

1>`at now + 2 minutes`

2>`date > /root/date200.log(退出)`

案例5：删除已经设置的任务，`atrm`+编号

`atrm + 编号`

> 补充：既可以执行指令，也可以执行shell脚本，脚本的后缀为`.sh`

# 十二、Linux磁盘分区、挂载

## 1、Linux分区

### 1）概念简介

​	Linux无论有几个分区，分给哪一目录使用，它归根结底就**只有一个根目录**，**一个独立且唯一的文件结构**，Linux中每个分区都是用来组成整个文件系统的一部分。

​	Linux采用了一种叫【**载入**】的处理方法，它的整个文件系统中包含了一整套的文件和目录，且**将一个分区和一个目录联系起来**。这时要载入的一个分区将使它的存储空间在一个目录下获得。

### 2）硬盘说明

​	Linux硬盘**分IDE硬盘和SCSI硬盘**，**目前基本上是SCSI硬盘**

​	对于**IDE硬盘**，驱动器标识符为`“hdx~”`，其中`“hd”`表明**分区所在设备的类型**，这里是指IDE硬盘了。`”x”`为盘号（**a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘**），`“~”`**代表分区**，**前四个分区用数字1到4表示**，**它们是主分区或扩展分区**，**从5开始就是逻辑分区**。

​	例：`hda3`表示为**第一个IDE硬盘上的第三个主分区或扩展分区**，`hdb2`表示为**第二个IDE硬盘上的第二个主分区或扩展分区**。

​	对于SCSI硬盘则**标识**为`“sdx~”`，SCSI硬盘是**用`“sd”`来表示分区所在设备的类型的**，其余则和IDE硬盘的表示方法一样。

### 3）查看所有设备挂载情况

​	**指令：**`lsblk`	或	`lsblk -f`	(看的更清晰点)

> **补充：**
>
> `lsblk -f`	指令查询到的信息的关键词详解
>
> `NAME`	：**名字**
>
> `FSTYPE`	：**文件类型**
>
> `LABEL`	：**分区情况**
>
> `UUID`	：**唯一标识符（分区格式化后分配一个唯一，不重复，40位的字符串）**
>
> `MOUNTPOINT`	：**挂载点**

## 2、挂载详细流程

> 挂载就是硬件与目录关联上了，拿硬盘来说，硬盘与目录关联上了，就是在目录中添加内容时，直接放在了硬盘中。目录可以访问硬盘空间了，并可以使用硬盘空间了
>
> 而卸载就是将硬盘与目录之间关联的关系给断掉，就是卸载 

### 1>虚拟机添加硬盘

1. 虚拟机菜单
2. 设置
3. 一路下一步到设置磁盘空间
4. 修改磁盘空间
5. 一路下一步，直到完成
6. 重启

![](image\添加新硬盘.png)

### 2>分区

**命令：**`fdisk 目录`

**这里是**：`fdisk /dev/sdb`

`m`：显示命令列表

`p`：显示磁盘分区，同	`fdisk -l`

`n`：新增分区

`d`：删除分区

`w`：写入并退出

**说明：开始分区后输入`n`，新增分区，然后选择`p`，分区类型为主分区。两次回车默认剩余全部空间。最后输入`w`写入分区并退出，若不保存退出输入`q`。**

### 3>格式化

**格式化磁盘：**

**分区命令**：`mkfs -t ext4 /dev/sdb1`

其中`ext4`是**分区类型**，`/dev/sdb1`是**关联目录**

> **补充**：
>
> 关联目录的第四位数字为多少，就表示该磁盘下有多少个分区

### 4>挂载/卸载

> 可以将挂载和卸载理解为U盘，**插入并可以打开使用就是挂载上了**，就是**硬件与目录关联上了**，而**卸载就相当于弹出u盘**，这个时候，**即使U盘还插在电脑上，也用不了**

**挂载：**`mount 设备名称/挂载目录`

例：`mount /dev/sdb1 /newdisk`

**卸载：**`umount 设备名称/挂载目录`

例：`umount 设备名称/挂载目录`

> **注意**：用命令行挂载，重启后会失效

### 5>设置可以自动挂载

**永久挂载：通过修改`/etc/fstab`实现永久挂载**

> 修改时，有两种方案：
>
> 1、直接添加UUID和关联目录，其他按配置填写
>
> 2、直接写硬盘路径，后面写关联路径即可

**添加完成后，执行`mount -a`即刻生效**

## 3、磁盘情况查询

> 查询系统整体磁盘使用情况

### 1）查询整体磁盘占用

**基本语法：**

​	`df -h`

### 2）查询指定目录的磁盘的占用

**基本语法**：

`du -h /目录`（**查询指定目录的磁盘占用情况，默认为当前目录**）

`-s`：**指定目录占用大小汇总**

`-h`：**带计量单位**

`-a`：**含文件**

`--max-depth=1`：**子目录深度**

`c`：**列出明细的同时，增加汇总值**



**应用案列：**

查询`/opt`目录的磁盘占用情况，深度为1

## 4、案例

### 1）统计/opt文件夹下文件的个数

`ls -1 /opt grep "^-" | wc -l`

### 2）统计/opt文件夹下目录的个数

`ls -1 /opt grep "^d" | wc -l`

### 3）统计/opt文件夹下文件的个数，包括子文件夹里的

`ls -lR /opt | grep "^-" | wc -l`

### 4）统计/opt文件夹下目录的个数，包括子文件夹里的

`ls -lR /opt | grep "^d" | wc -1`

### 5）以树状显示目录结构tree目录

**指令：`tree 目录`**

**注意，如果没有tree，则使用yum install tree安装**

# 十三、网络配置

## 1、Linux网络配置原理图

![](image\网络原理图.png)

## 2、查看网络IP和网关

### 1）查看虚拟网络编辑器和修改IP地址

### 2）查看网关

**虚拟网络编辑器 -> NAT设置 -> 网关IP设置**

### 3）查看windows环境中的VMnet8网络配置

**cmd窗口下使用ipconfig指令**

### 4）查看linux的网络配置

**linux终端下使用ifconfig指令**

### 5）ping测试主机之间网络连通性

**基本语法**：`ping 目的主机IP`

### 6）Linux网络环境配置

#### 1>自动获取

说明：登陆后，通过界面来设置自动获取ip

特点：linux启动后会自动获取IP，缺点是每次自动获取的ip地址可能不一样

**流程：Linux系统下 --> 界面左上角【应用程序】 --> 系统工具 --> 设置 --> 网络 --> 齿轮图标 --> IPV4 --> 自动获取**

#### 2>指定IP

**说明：**

​	直接修改配置文件来指定IP，并可以连接到外网（程序员推荐）

**编辑`vi /etc/sysconfig/network-scripts/ifcfg-ens33`**：

​	要求：将ip地址配置成静态的，比如：ip地址为192.168.200.130



**`ifcfg-ens33`文件说明：**

​	`DEVICE=eth0`：**#接口名（设备，网卡）**

​	`HWADDR=00:0C:2x:6x:0x:xx`：**#MAC地址**

​	`TYPE=Ethernet`：**#网络类型（通常是Ethemet)**

​	`UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44`：**#随机id**

​	`ONBOOT-yes`：**#系统启动的时候网络接口是否有效(yes/no)**

​	`BOOTPROTO=static`：**#IP的配置方法（none|static|bootp|dhcp）（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）**

​	`IPADDR=192.168.200.130`：**#IP地址**

​	`GATEWAY=192.168.200.2`：**#网关**


​	`DNS1=192.168.200.2`：**#域名解析器**

**重启网络服务或者重启系统生效**：

​	`service network restart、reboot`指令

**详细流程：**

1. 编辑`vi /etc/sysconfig/network-scripts/ifcfg-ens33`文件
2. 将`BOOTPROTO=dhcp`改为`BOOTPROTO=static`
3. 在末尾添加：
   1. IP地址：`IPADDR=192.168.200.130`
   2. 网关：`GATEWAY=192.168.200.2`
   3. 域名解析器：`DNS1=192.168.200.2`
4. 保存并退出
5. 配置**虚拟机的IP地址，也就是VM的子网，保证第三段，也就是网段的一致**
6. 在**NAT设置中编辑网关IP**，**保证网关IP与IP地址的第三段一致**

> VM虚拟机也有一个IP地址，但是**Linux系统想要ping通VM虚拟机**，就**需要主机也就是母机关闭防火墙**

## 3、设置主机名和hosts映射

### 1）设置主机名

1. 为了方便记忆，可以给Linux系统设置主机名，也可以根据需要修改主机名
2. 指令：`hostname`：**查看主机名**
3. 修改文件在`/etc/hostname`指定
4. 修改后，重启生效

### 2）设置hosts映射

**思考：如何通过主机名能够找到（比如ping)某个Linux系统？**

**windows中：**

在`C:\Windows\System32\drivers\etc\hosts`文件指定即可

案例：`192.168.200.130 hspedu100`

**Linux中：**

在`/etc/hosts 文件指定`

案例：`192.168.200.1 ThinkPad-PC`

### 3）主机名解析过程分析

#### a> Hosts是什么：

​	一个文本文件，用来记录IP和Hostname（主机名）的映射关系

#### b> DNS：

1. DNS，就是`Domain Name System`的缩写，翻译过来就是域名系统

2. 是互联网上作为域名和IP地址相互映射的一个分布式数据库

#### c>结合案例分析

**案例：用户在浏览器输入了`www.baidu.com`**

1. 浏览器**先检查浏览器缓存**中有没有该域名解析IP地址，有就先调用这个IP完成解析；**如果没有，就检查DNS解析器缓存**，如果有直接返回IP完成解析。这**两个缓存，可以理解为本地解析器缓存**

2. 一般来说，当**电脑第一次成功访问某一网站后**，在一定时间内，**浏览器或操作系统会缓存他的IP地址（DNS解析记录）**如在cmd窗口中输入：

   `ipconfig /displaydns`：//**DNS域名解析缓存**

   `ipconfig /flushdns`：//**手动清理dns缓存**

3. 如果**本地解析器缓存没有找到对应映射**，**检查系统中hosts文件中有没有配置对应的域名IP映射**，如果有，则完成解析并返回。

4. 如果 **本地DNS解析器缓存 和 hosts 文件中均没有找到对应的IP**则**到域名服务DNS进行解析域**

**解析原理图：**

![](image\域名解析原理.png)

# 十四、进程管理

## 1、基本介绍

1. 在LINUX中，每个**执行的程序**都称为一个进程。**每一个进程都分配一个ID号**(pid，进程号)。
2. 每个进程都可能**以两种方式存在的**。**前台**与**后台**，所谓**前台进程就是用户目前的屏幕上可以进行操作的**。**后台进程则是实际在操作，但由于屏幕上无法看到的进程**，通常使用后台方式执行。
3. 一般**系统的服务都是以后台进程的方式存在**，而且都**会常驻在系统中**。直到关机才结束。

## 2、显示系统执行的进程

### 1）基本介绍

​	**ps命令**是用来**查看目前系统中，有哪些正在执行的进程**，以及它们执行的状况。可以不加任何参数



**ps显示的信息选项：**

|  字段  |          说明          |
| :----: | :--------------------: |
| `PID`  |       进程识别号       |
| `TTY`  |        终端机号        |
| `TIME` |   此进程所消CPU时间    |
| `CMD`  | 正在执行的命令或进程名 |



**补充指令：**

​	`ps -a`：**显示当前终端的所有进程信息**

​	`ps-u`：**以用户的格式显示进程信息**

​	`ps -x[]`：**显示后台进程运行的参数**

### 2）ps详解

1. 指令：`ps -aux|grep xxx`，比如我看看有没有`sshd`服务
2. **指令说明：**
   - `System V`：展示风格
   - `USER`：用户名称
   - `PID`：进程号
   - **`%CPU`：进程占用CPU的百分比**
   - **`%MEM`：进程占用物理内存的百分比**
   - **`VSZ`：进程占用的虚拟内存大小（单位：KB)**
   - **`RSS`：进程占用的物理内存大小（单位：KB)**
   - `TT`：终端名称，缩写。
   - `STAT`：进程状态：
     - 其中，`S-`：睡眠
     - `s-`：表示该进程是会话的先导进程
     - `N-`：表示进程拥有比普通优先级更低的优先级
     - `R-`：正在运行
     - `D-`：短期等待
     - `Z-`：僵死进程
     - `T-`：被跟踪或者被停止等等
   - `STARTED`：进程的启动时间
   - `TIME`：CPU时间，即进程使用CPU的总时间
   - `COMMAND`：启动进程所用的命令和参数，如果过长会被截断显示

### 3）应用实例

**要求：以全格式显示当前所有的进程，查看进程的父进程。查看Sshd的父进程信息**：

> **补充**：
>
> `ps -ef`：是以全格式显示当前所有的进程
>
> `-e`：显示所有进程
>
> `-f`：全格式
>
> `ps -ef|grep xxx`

- 是BSD风格
- `UID`：用户ID
- `PID`：进程ID
- `PPID`：父进程ID
- `C`：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是`I/O`密集型运算，执行优先级会提高
- `STIME`：进程启动的时间
- `TTY`：完整的终端名称
- `TIME`：CPU时间
- `CMD`：启动进程所用的命令和参数

## 3、终止进程kill和killall

### a>介绍

若是**某个进程执行一半需要停止时**，或是**已消耗很大的系统资源时**，此时**可以考虑停止该进程**。使用 kill 命令来完成此项任务。

### b>基本语法

`kill [选项] 进程号`：（功能：**通过进程号杀死进程**）

`killall 进程名称`：（功能：**通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用**）

### c>常用选项

`-9`：**表示强迫进程立即停止**

### d>实践案例

案例1：踢掉某个非法登录用户

`kill 对应的进程号`（通过`ps -aux|grep sshd`查询进程号）

案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务

`kill sshd对应的进程号`

重启sshd服务：`/bin/systemctl start sshd.service`

案例3：终止多个gedit

`killall gedit`

案例4：强制杀掉一个终端

`kill -9 bash对应程序号`

## 4、查看进程树pstree

### a>基本语法

`pstree [选项]`，可以更加直观的来看进程信息

### b>常用选项

`-p`：显示进程的PID

`-u`：显示进程的所属用户

### c>应用实例：

案例1：请你以树状的形式显示进程的pid

`pstree -p`

案例2：请你以树状的形式显示进程的用户id

`pstree -u`

## 5、服务(service)管理

### 1） 介绍：

​	**服务（service）本质就是进程**，但是**是运行在后台的**，**通常都会监听某个端口**，等待其它程序的请求，比如（mysql，sshd 防火墙等），因此我们又称为**守护进程**，是Linux中非常重要的知识点。【原理图】

### 2）service管理指令

1. service服务名[**start|stop|restart|reload|status**]

2. 在CentOS7.0后 **很多服务不再使用service，而是systemctl**（后面专门讲）

3. service指令管理的服务在`/etc/init.d`查看

### 3） service管理指令案例

​	请使用service指令，查看，关闭，启动 network [注意：在虚拟系统演示，因为网络连接会关闭]

​	`service network stop`：关闭network网络服务

​	`service network start`：开启network网络服务

### 4） 查看服务名

方式1：使用setup --> 系统服务 就可以看到**全部**

> **系统服务前面的星 * 表示自启动，<u>输入空格就可以取消这个星星</u>，<u>再次输入空格就可以加上这个星星</u>**

方式2：`/etc/init.d` 看到 service 指令管理的服务

### 5）服务的运行级别

​	**Linux系统有7种运行级别**（runlevel）：**常用的是级别3和5**

- 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
- 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
- 运行级别2：多用户状态（没有NFS),不支持网络
- 运行级别3：完全的多用户状态（有NFS)，登陆后进入控制台命令行模式
- 运行级别4：系统未使用，保留
- 运行级别5：X11控制台，登陆后进入图形GUI模式
- 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动



​	**开机流程说明**：

![](image\开机流程.png)

### 6）运行级别回顾

**CentOS7后运行级别说明**：

在`/etc/initab`设置

进行了简化，如下：

`multi-user.target:analogous to runlevel 3`

`graphical.target:analogous to runlevel 5`

#To view current default target，run：

`systemctl get-default`

#To set a default target，run：

`systemctl set-default TARGET.target（运行级别）`

### 7）chkconfig指令

#### a> 介绍

1. 通过`chkconfig`命令可以给服务的**各个运行级别设置 自启动/关闭**
2. `chkconfig`指令管理的服务在`/etc/init.d`查看
3. 注意：Centos7.0后，很多服务**使用`systemctl`管理**（后面马上讲）

#### b> chkconfig基本语法

查看服务：`chkconfig --list [|grep xxx]`（功能：查看服务在各级别情况下的开关情况）

`chkconfig 服务名 --list`（功能：查看指定服务在各级别情况下的开关情况）

`chkconfig --level 5 服务名 on/off`（功能：设置指定级别的指定服务的开关）

#### c> 案例演示

**对 network 服务 进行各种操作**

`chkconfig level 3 network off`（功能：在运行级别3的情况下，关闭 network (网络服务) 的自启动）

`chkconfig level 3 network on` （功能：在运行级别3的情况下，开启 network (网络服务) 的自启动）

#### d> 使用细节

​	**`chkconfig`重新设置服务后自启动或关闭，需要重启机器`reboot`生效。**

### 8）systemctl指令

#### a> systemctl 管理指令

1. **基本语法**：`systemctl [start|stop|restart|status] 服务名`

2.  `systemctl` 指令管理的服务在 `/usr/lib/systemd/system` 查看

#### b> systemctl 设置服务的自启动状态

1.  `systemctl list-unit-files [|grep 服务名]`	（**查看服务开机启动状态，grep可以进行过滤**）
2.  `systemctl enable 服务名`	（**设置服务开机启动，默认运行级别为3和5**）
3.  `systemctl disable 服务名`	（**关闭服务开机启动，默认运行级别为3和5**）
4.  `systemctl is-enabled 服务名`	（**查询某个服务是否是自启动的**）

#### c> 应用案例：

​	查看当前防火墙的状况，关闭防火墙和重启防火墙。

**流程**：

1、在  `/usr/lib/systemd/system` 下通过  `systemctl list-unit-files |grep fire（英文为火）` （功能：找到防火墙服务的服务名称，为 `firewalld.service`）

2、 通过 `systemctl status firewalld ` 查看当前防火墙的状态

3、 通过 `systemctl stop firewalld ` 关闭防火墙

4、 通过 `systemctl start firewalld ` 开启防火墙

#### d> 细节讨论：

1. 关闭或者启用防火墙后，立即生效。[ telnet 测试 某个端口 即可]
2. 这种方式只是**临时生效**，当**重启系统后**，还是**回归以前对服务的设置**。
3. 如果希望**设置某个服务自启动或关闭永久生效**，要使用 `systemctl [enable|disable] 服务名`。[演示]

> **补充**：**防火墙的基本原理**
>
> **端口管理器和外界访问过滤器**
>
> 管理端口是否对外界开放，对外开放，那么外界就可以访问这个程序，不对外开放，那么外界就不能访问这个程序

### 9）打开或者关闭指定端口

> ​	简介：在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部情求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、8080等，这个又怎么做呢？

#### firewall指令

1. 打开端口：`firewall-cmd --permanent --add-port=端口号/协议`

2. 关闭端口：`firewall-cmd --permanent --remove-port=端口号/协议`

3. 重新载入，才能生效：`firewall-cmd --reload`

4. 查询端口是否开放：`firewall-cmd --query-port=端口/协议`

#### 应用案例：

1> 启用防火墙，测试 111端口 是否能 telnet

`systemctl start firewall` ：（启用防火墙）

`telnet 192.168.200.128(IP地址)` ：（测试 111端口 是否能 telnet）

2> 开放111端口

指令 `netstat -anp|more` ：查询服务的状态和协议，这里是为了确定111端口所用的协议

`firewall-cmd --permanent --add-port=111/tcp` ：打开111端口

`firewall-cmd --reload` ：重新加载

3> 再次关闭111端口

`firewall-cmd --permanent --remove-port=111/tcp` ：关闭端口

`firewall-cmd --reload` ：重新加载

## 6、动态监控进程

> 介绍：top 与 ps 命令很相似。它们都用来**显示正在执行的进程**。Top 与 ps 最大的不同之处，在于 **top 在执行一段时间可以更新正在运行的进程**。

### 1）基本语法

 `top [选项]`

#### 选项说明：

|   选项    |                     功能                     |
| :-------: | :------------------------------------------: |
| `-d` 秒数 |      指定top命令每隔几秒更新。默认是3秒      |
|   `-i`    |       使top不显示任何闲置或者僵死进程        |
|   `-P`    | 通过指定监控进程 ID 来仅仅监控某个进程的状态 |

**查询信息详解：**

​	**第一行：**

​	`top - xx：xx：xx up` ：表示现在时间

​	`up xx：xx` ：表示系统运行时间

​	`数字 user` ：表示当前用户数量

​	`load average` ：表示负载均衡，有三个数值，当**三个数值相加除以3大于 0.7(70%) 时，需要注意，资源不足问题，需要对性能进行提升**

​	**第二行：**

​	`Tasks 数字 total` ：任务数

​	`数字 running` ：正在运行的程序

​	`数字 sleeping` ：休眠程序

​	`数字 stopped` ：停止程序

​	`数字 zombie` ：僵死程序 （程序已死，但是占用的内存没有释放，就是僵死进程）

​	**第三行：**

​	`%Cpu(s)` ：CPU占用情况

​	`数.数 us` ：用户占用的CPU

​	`数.数 sy` ：系统占用的CPU

​	`数.数 id` ：空闲的CPU

​	**第四行：**

​	`KiB Mem` ：内存占用情况

​	`数字 total` ：内存总量

​	`数字 free` ：未被占用的内存，即空闲内存

​	`数字 used` ：已被占用的内存，即已使用内存

​	`数字 buff/cache` ：内存占用情况

​	**第五行：**

​	`KiB Swap` ：Swap分区情况

​	`数字 total` ：内存总量

​	`数字 free` ：未被占用的内存，即空闲内存

​	`数字 used` ：已被占用的内存，即已使用内存

​	`数字 avail Mem` ：可获取的内存情况

> 空闲内存极少的情况下，要考虑是否为内存泄漏，或者是内存不够的情况，内存不够的话需要升级内存

### 2）交互操作说明

| 操作 |              功能               |
| :--: | :-----------------------------: |
| `P`  | 以 CPU 使用率排序，默认就是此项 |
| `M`  |       以内存的使用率排序        |
| `N`  |           以 PID 排序           |
| `q`  |             退出top             |

**应用实例**：

案例1：**监视特定用户**

​	top：输入此命令，按回车键，查看执行的进程。

​	u：然后输入 “u” 回车，再输入用户名，即可

案例2：**终止指定的进程**

​	top：输入此命令，按回车键，查看执行的进程。

​	k：然后输入 “k” 回车，再输入要结束的进程 PID 号 （ bash 的服务）

案例3：**指定系统状态更新的时间**（每隔10秒自动更新）

​	`top -d 10` ：指定10秒更新状态

### 3）监控网络状态

#### a> netstat指令

> **查看系统网络状态**

##### 基本语法

​	`netstat [选项]`

##### 选项说明

​	`-an`	：按一定顺序排列输出
​	`-P` ：显示哪个进程在调用

##### 应用案例

​	请查看服务名为sshd的服务的信息。

​	`netstat -anp|grep sshd`

##### 查询列表信息说明

​	`Proto` ：协议信息

​	`Local Address` ：本地地址 （系统内部地址）

​	`Foreign Address` ：外部地址 （系统之外的地址）

#### b> ping指令

> **检测主机连接命令**

是一种网络检测工具，它主要是用**检测远程主机是否正常**，或是两部主机间的网线或网卡故障。

如：ping 对方 ip 地址

# 十五、RPM与YUM

## 1、rpm包的管理

### 1）介绍

​	**rpm 用于互联网下载包的打包及安装工具**，它包含在某些 Linux 分发版中。它**生成具有 .RPM 扩展名的文件**。RPM 是 RedHat Package Manager （**RedHati软件包管理工具）的缩写**，类似 windows 的 setup.exe ，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。

 Linux 的分发版本都有采用（suse，redhat，centos等等），可以算是公认的行业标准了。

### 2）rpm包的简单查询指令

​	**查询已安装的 rpm 列表：** `rpm -qa|grep xx`

### 3）rpm包名基本格式

一个 rpm 包名：`firefox-60.2.2-1.el7.centos.x86_64`

名称：firefox

版本号：60.2.2-1

适用操作系统：el7.centos.x86_64

表示 centos7.x 的 64 位系统

如果是 **i686、i386 表示 32 位系统**，**noarch 表示通用**。。

### 4）rpm包的其它查询指令



`rpm -qa` ：**查询所安装的所有 rpm 软件包**

`rpm -qa|more`

`rpm -qa|grep X [rpm -ga|grep firefox]`



`rpm -q 软件包名` ：**查询软件包是否安装**

​	案例：`rpm -q firefox`



`rpm -qi 软件包名` ：**查询软件包信息**

​	案例：`rpm -qi firefox`



`rpm -ql 软件包名` ：**查询软件包中的文件**

​	比如：`rpm -ql firefox`



`rpm -qf 文件全路径名` ：**查询文件所属的软件包**

​	`rpm -qf /etc/passwd`

​	`rpm -qf /root/install.log`

### 5）卸载 rpm 包

#### 基本语法：

​	`rpm -e RPM包的名称`

#### 应用案例：

​	删除 firefox 软件包

#### 细节讨论：

- **如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。**

  ​	如：`$rpm -e foo`

`removing these packages would break dependencies:foo is needed by bar-1.0-1`

- 如果我们就是要删除 foo 这个 rpm 包，可以**增加参数 - -nodeps ，就可以强制删除**，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行

  ​	如：`$rpm -e --nodeps foo`

### 6）安装 rpm 包

#### 基本语法：

​	`rpm -ivh RPM包全路径名称`

#### 参数说明：

​	`i=install` ：安装

​	`v=verbose` ：提示

​	`h=hash` ：进度条

#### 应用实例：

​	演示卸载和安装 firefox 浏览器

​	`rpm -e firefox` ：卸载火狐

​	在 CentOS 7 ×86_64 光盘中找到 Packge ，在 Packge 中找到 firefox 安装包，并将其复制到 opt 目录下

​	`rpm -ivh /opt/火狐安装包全名` ，火狐安装包全名敲一个前置的名字，然后 Tab 键即可

## 2、yum

### 介绍：

​	Yum 是一个 **Shell 前端软件包管理器**。**基于RPM包管理**，**能够从指定的服务器自动下载RPM包并且安装**，**可以自动处理依赖性关系**，并且一次安装所有依赖的软件包。

### yum的基本指令：

**查询 yum 服务器是否有需要安装的软件**

​	`yum list|grep xx软件列表`

**安装指定的yum包**

​	`yum install xxx` ：下载安装

### yum应用实例：

​	案例：请使用 yum 的方式来安装 firefox

​	`rpm -e firefox`

​	`yum list|grep firefox`

​	`yum install firefox`

# 十六、搭建JavaEE环境

## 1、安装JDK

### 安装步骤

1. `mkdir /opt/jdk` ：创建JDK目录

2. 通过 xftp6 上传到 `/opt/jdk` 下

3. `cd /opt/jdk`

4. 解压 `tar -zxvf jdk-8u261-linux-x64.tar.gz`

5. `mkdir /usr/local/java`

6. `mv /opt/jdk/jdk1.8.0_261 /usr/local/java`

7. 配置环境变量的配置文件 `vim /etc/profile`

8. `export JAVA_HOME=/usr/local/java/jdk1.8.0_261`

9. `export PATH=$JAVA_HOME/bin:$PATH`
10. `source /etc/profile` ：刷新，[让新的环境变量生效]

**测试是否安装成功**

​	编写一个简单的 `Hello.java` 输出 `"hello,world!" `

## 2、安装Tomcat

### 步骤：

1. 上传安装文件，并解压缩到 `/opt/tomcat`

2. 进入解压目录 `/bin`，启动 tomcat ` ./startup.sh`

3. 开放端口 8080

**测试是否安装成功：**

​	在windows、Linux 下访问 `http://linuxip:8O80`

## 3、安装IDEA2020

### 步骤

1. 下载地址：`https://www.jetbrains.com/idea/download/#section=windows`

2. 解压缩到 `/opt/idea`

3. 启动 `idea bin` 目录下 `./idea.sh` ，配置 jdk

4. 编写 `Hello world` 程序并测试成功！

## 4、MySQL5.7的安装

### 步骤：

1. 新建文件夹 `/opt/mysql` ，并 cd 进去

2. 运行 `wget http://dev.mysq1.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar` ，下载 mysql 安装包
   - PS： `centos'7.6` 自带的类 mysql 数据库是 mariadb ，会跟 mysql 冲突，要先删除。
3. `tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar` ：解压准备好的MySQL安装包

4. 运行 `pm -qa|grep mari` ，查询 `mariadb` 相关安装包

5. 运行 `pm -e --nodeps mariadb-libs` ，卸载 mariadb 和 marisa 安装包

6. 然后开始真正安装 mysql ，依次运行以下几条，**按顺序！**

   - `rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm`

   - `rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm`

   - `rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm`

   - `rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm`

7. 运行 `systemetl start mysqld.service` ，启动 mysql

8. 然后开始设置 root 用户密码
   - Mysql 自动给 root 用户设置随机密码，运行 `grep "password" /var/1og/mysqld.log` 可看到当前密码
9. 运行 `mysql -u root -p` ，用 root 用户登录，提示输入密码可用上述的，可以成功登陆进入 mysql 命令行

10. 设置 root 密码，对于个人开发环境，如果要设比较简单的密码（**生产环境，服务器要设复杂密码**），可以运行

    - `set global validate_password_policy=0;` ：提示密码设置策略（密码没有达到响应的要求会给出提示	）

    - `(validate_password policy默认值l,)`

11. `set password for 'root'@'localhost'=password('hspedu100);`

12. 运行 `flush privileges;` 使密码设置生效

# 十七、大数据-Shell编程

## 0、前言

1. Linux 运维工程师在进行服务器集群管理时，需要编写 Shell 程序来进行服务器管理。

2. 对于 JavaEE 和 Python 程序员来说，工作的需要，你的老大会要求你编写一些 Shell 脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。

3. 对于大数据程序员来说，需要编写 Shel l程序来管理集群。

## 1、Shell是什么

​	Shell 是一个**命令行解释器**，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用Shells来启动、挂起、停止甚至是编写一些程序。

## 2、Shell 脚本的执行方式

### 1）脚本格式要求：

1.脚本以 `#！/bin/bash` 开头

2.脚本需要有可执行权限

### 2）编写第一个 Shell 脚本：

​	需求说明：创建一个 Shell 脚本，输出 hello world！

​	`mkdir /root/shcode` ：创建 shcode 目录

​	`vim hello.sh` ：创建 Shell 脚本文件，约定为 .sh 为后缀，也可以不用该后缀，但是这是约定，最好是这样

​	`#!/bin/bash` ：编写文件开头

​	`echo "Hello,World";` ：编写文件具体内容

### 3）脚本的常用执行方式

方式1（输入脚本的绝对路径或相对路径）

​	说明：首先要赋予 helloworld.sh 脚本的 +x 权限，再执行脚本

​	`chmod u+x hello.sh` ：赋给文件执行的权限

​	`./hello,sh` ：以相对路径的方式执行文件

​	`/root/shcode/hello.sh` ：以绝对路径的方式执行文件

> 这种方式都需要给权限

方式2（ sh+脚本）

​	说明：不用赋予脚本 +x 权限，直接执行即可。

​	`sh hello.sh` ：直接执行文件，当作脚本执行

> 这种方式不需要给权限

## 3、Shell 的变量

### 1）Shell变量介绍

1. Linux Shell 中的变量分为，**系统变量**和**用户自定变量**。

2. 系统变量：`$HOME、$PWD、$SHELL、$USER` 等等，比如：`echo $HOME` 等等...

3. 显示当前 sheIl 中所有变量：set

4. Shell 中变量一般都用 $ 表示

### 2）shell变量的定义

#### a> 基本语法

1.**定义**变量：`变量=值` （注意：中间不能有空格）

2.**撤销**变量：`unset 变量`

3.**声明静态**变量：`readonly变量` ，注意：不能unset

#### b> 快速入门

案例1：定义变量A

`A=1`

`echo A=$A` ：输出变量A，前面的A会被当作字符处理，加了$符的会被当作变量处理

案例2：撤销变量A

`unset A`

案例3：声明静态的变量 B=2，不能 unset

`readonly B=2`

不能撤销静态变量

案例4：可把变量提升为全局环境变量，可供其他 shell 程序使用

#### c> 定义变量的规则

1. 变量**名称可以由字母、数字和下划线组成**，但是**不能以数字开头**。例：`5A=200 (×)`

2. 等号两侧**不能有空格**

3. 变量名称**一般习惯为大写**，这是一个**规范**

#### d> 将命令的返回值赋给变量

1. A=`data` 反引号，**运行里面的命令**，并**把结果返回给变量A**，（反引号就是Tab上面的哪个引号）
2. A=$(date) 等价于反引号

### 3）设置环境变量

#### a> 基本语法

1. `export 变量名=变量值` ：（功能描述：将shell变量输出为环境变量/全局变量）

2. `source 配置文件` ： (功能描述：让修改后的配置信息立即生效)

3. `echo $变量名` ： (功能描述：查询环境变量的值)

#### b> 快速入门

1.在 `/etc/profile` 文件中定义 `TOMCAT_HOME` 环境变量

2.查看环境变量 `TOMCAT_HOME` 的值

3.在另外一个 shell 程序中使用 `TOMCAT_HOME`



> 注意：在输出 `TOMCAT_HOME` 环境变量前，需要让其生效
>
> ​	`source /etc/profile`
>
> 补充：多行注释
>
> ​	格式为：`:<<! 内容 !`，开头和结尾分别单独占一行

### 4）位置参数变量

#### a> 介绍

​	当我们执行一个 Shell 脚本时，如果**希望获取到命令行的参数信息**，就可以使用到位置参数变量

​	比如：`./myshell.sh 100 200` ，这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息

#### b> 基本语法

`$n` （功能描述：`n` 为数字，`$0` 代表命令本身，`$1-$9` 代表第一到第九个参数，十以上的参数需要用大括号包含，如 `${10}` ）

`$*` （功能描述：这个变量代表命令行中所有的参数，`$*` 把所有的参数看成一个整体）

`$@` （功能描述：这个变量也代表命令行中所有的参数，不过 `$@` 把每个参数区分对特）

`$#` （功能描述：这个变量代表命令行中所有参数的个数）

#### c> 案例

​	案例：编写一个 shell 脚本 position.sh ，在脚本中获取到命令行的各个参数信息。

​	`echo "$0 $1 $2"`

​	`echo 所有参数信息=$*`

​	`echo 所有参数个数为=$#`

### 5）预定义变量(了解)

#### a> 基本介绍

​	就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用

#### b> 基本语法

​	`$$` （功能描述：当前进程的进程号（PID））

​	`$!` （功能描述：后台运行的最后一个进程的进程号(PID））

​	`$？` （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。)

#### c> 应用实例

​	在一个 shell 脚本中简单使用一下预定义变量
​	`preVar.sh`

> 以后台方式运行脚本，在末尾加一个 & 即可

### 6）运算符

#### a> 基本介绍

​	学习如何在 shell 中进行各种运算操作。

#### b> 基本语法

1. `"$((运算式))"` 或 `"$[运算式]"` 或者 `expr m + n` // expression 表达式（每个字母中间都有空格）

2. 注意 expr 运算符间要有空格，如果希望将 expr 的结果赋给某个变量，使用 `` 反引号

3. `expr m - n`

4. `expr \*,/,%` 乘 \\*，除 /，取余 %

#### c> 应用实例

案例1：计算 (2+3)X4 的值

`$[(2+3)*4]`

案例2：请求出命令行的两个参数[整数]的和

`$[$1+$2]`

### 7）条件判断

#### a> 基本语法

​	`[ condition ]` （注意 condition 前后要有空格）

​	#**非空返回 true** ，可使用 $？ 验证（ 0 为 true ，>1 为 false ）

#### b> 应用实例

|            案例            |           结果           |
| :------------------------: | :----------------------: |
|        `[ hspEdu ]`        |         返回true         |
|           `[ ]`            |        返回 false        |
| `[ condition ] && echo OK` | 条件满足，执行后面的语句 |

#### c> 常用判断条件

##### 1）= 字符串比较

##### 2）两个整数的比较

| 指令  |          含义           |
| :---: | :---------------------: |
| `-lt` |          小于           |
| `-le` | 小于等于 `little equal` |
| `-eq` |          等于           |
| `-gt` |          大于           |
| `-ge` |        大于等于         |
| `-ne` |         不等于          |

##### 3）按照文件权限进行判断

| 指令 |     含义     |
| :--: | :----------: |
| `-r` |  有读的权限  |
| `-w` |  有写的权限  |
| `-x` | 有执行的权限 |

##### 4）按照文件类型进行判断

| 指令 |             含义             |
| :--: | :--------------------------: |
| `-f` | 文件存在并且是一个常规的文件 |
| `-e` |           文件存在           |
| `-d` |     文件存在并是一个目录     |

##### 5）应用实例

案例1：`"ok"` 是否等于 `"ok"`

判断语句：`=`

案例2：23是否大于等于22

判断语句：`23 -ge 22`

案例3：`/root/shcode/aaa.txt` 目录中的文件是否存在

判断语句：`-f`

### 8）流程控制

#### a> if 判断

##### 1）基本语法

​	`if [ 条件判断式 ]`

​	`then`

​	`代码`

​	`fi`

##### 2）多分支

​	`if [ 条件判断试 ]`

​	`then`

​	`代码`

​	`elif [ 条件判断式 ]`

​	`then`

​	`代码`

​	`fi`

​	注意事项：`[ 条件判断式 ]` ，**中括号和条件判断式之间必须有空格**

##### 3）应用实例 `ifCase.sh`

​	案例：请编写一个 shell 程序，如果输入的参数，大于等于60，则输出 `"及格了” `，如果小于60，则输出 `“不及格”`

#### b> case语句

##### 1）基本语法

​	`case $变量名 in`

​	` "值1")`

​	`程序1` （如果变量的值等于值1，则执行程序1）

​	`;;` （每一种情况结束，有两个分号做结尾）

​	`"值2”)`

​	`程序2` （如果变量的值等于值2，则执行程序2）

​	`;;`

…省略其他分支…

​	`*)`

​	`程序3` （如果变量的值都不是以上的值，则执行此程序）

​	`;;`

`esac` （整个程序的结束标识）

##### 2）应用实例`testCase.sh`

​	案例1：当命令行参数是1时，输出 `"周一"` ，是2时，就输出 `"周二”` ，其它情况输出 `"other”`

#### c> for循环

##### 1）基本语法1

`for 变量 in 值1 值2 值3 ...`

`do`

`程序/代码`

`done` （结束标识）

##### 2）基本语法2

`for (( 初始值; 循环控制条件; 变量变化))`

`do`

`程序/代码`

`done`

##### 3）应用实例 `testFor2.sh`

​	案例1：从1加到100的值输出显示

> `$*` 是将输入的参数当作一个整体来看待，不管有多少个，都一行输出
>
> `$@` 是将输入的参数分开来看，有多少个参数就是多少个参数，将每一个参数当作一个单独的个体来看待

#### d> while循环

##### 1）基本语法1

`while [ 条件判断式 ]`

`do`

`程序/代码`

`done`

> 注意：while 关键字与 [] 之间有空格，条件判断式与 [] 之间也有空格

##### 2）应用实例 `testWhile.sh`

​	案例1：从命令行输入一个数 n，统计从 1+...+n 的值是多少？

### 9）read读取控制台输入

#### a> 基本语法：

`read (选项)(参数)`

#### b> 选项：

​	`-p` ：指定读取值时的提示符；
​	`-t` ：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。。

#### c> 参数

​	变量：指定读取值的变量名

#### d> 应用实例`testRead.sh`

​	案例1：读取控制台输入一个 num 值

​	`read -p "请输入第一个数NUM1=" NUM1`

​	案例2：读取控制台输入一个 num 值，在 10 秒内输入。

​	`read -t 10 -p "请输入第一个数NUM1=" NUM1` ：表示等待10秒，10秒后仍未输入，就自动退出

### 10）函数

#### a> 函数介绍

​	shell 编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。

#### b> 系统函数

##### 1）basename 基本语法

功能：**返回完整路径最后 / 的部分，常用于获取文件名**

`basename [pathname][suffix]`

`basename [string][suffix]` ：（功能描述：basename 命令会删掉所有的前缀包括最后一个`（'/'）`字符，然后将字符串显示出来。

###### 1> 选项：

​	suffix 为**后缀**，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。

###### 2> 应用实例

​	案例1：请返回 `/home/aaa/test.txt` 的 `"test.txt"` 部分

​	`basename /home/aaa/test.txt`

​	`basename /home/aaa/test.txt .txt` ：如果是这种形式，则就会将 .txt 去掉，只返回文件名

##### 2）dirname 基本语法

​	功能：**返回完整路径最后 / 的前面的部分，常用于返回路径部分**

​	`dirname 文件绝对路径` ：（功能描述：**从给定的包含绝对路径的文件名中去除文件名**（非目录的部分)，**然后返回剩下的路径**（目录的部分）)

###### 1> 应用实例

​	案例1：请返回 `/home/aaa/test.txt` 的 `/home/aaa`

#### c> 自定义函数

##### 1）基本语法

`[ funetion ] funname(){`

​		`Action;`

​		`[return int;]`

`}`

**调用直接写函数名**：`funname [值]`

##### 2）应用实例

​	案例1：计算输入两个参数的和（动态获取），getSum

```shell
#定义函数getSum
function getSum(){
	SUM=$[$n1+$n2]
	echo "和是=$SUM"
}
#输入两个值
read -p "请输入一个数n1=" n1
read -p "请输入一个数n2=" n2
#调用自定义函数
getSum $n1 $n2
```

### 11）综合实践

**需求案例及需求分析：**

​	1.每天凌晨 2：30 备份数据库 hspedu 到 `/data/backup/db`

​	2.备份开始和备份结束能够给出相应的提示信息

​	3.备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式，比如： `2021-03-12_230201.tar.gz`

​	4.在备份的同时，检查是否有 10 天前备份的数据库文件，如果有就将其删除。

**解决：**

1、在 /usr/sbin/ 下创建 mysql_db_backup.sh 脚本文件，编写脚本文件

```shell
#!/bin/bash
#备份目录
BACKUP=/data/backup/db
#获取当前的时间
DATETIME=$(date +%Y-%m-%d_%H%M%S)
echo $DATETIME
#数据库的地址
HOST=localhost
#数据库的用户
DB_USER=root
#数据库的密码
DB_PW=123456789
#备份的数据库名
DATABASE=xiaohu

#创建备份目录，如果不存在就创建
[ ! -d "${BACKUP}/${DATETIME}" ] && mkdir -p "${BACKUP}/${DATETIME}"

#备份数据库
mysqldump -u${DB_USER} -p${DB_PW} --host=${HOST} -q -R --databases ${DATEBASE} | gzip > ${BACKUP}/${DATETIME}/$DATETIME.sql.gz

#将文件处理成 tar.gz
cd ${BACKUP}
tar -zcvf $DATETIME.tar.gz ${DATETIME}
#删除对应的备份
rm -rf ${BACKUP}/${DATETIME}

#删除10天前的备份文件
find ${BACKUP} -atime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "备份数据库${DATABASE} 成功"                                   
```

2、创建一个定时任务调度的程序

```shell
30 2 * * * /usr/sbin/mysql_db_backup.sh
```

# 十八、日志管理

## 1、基本介绍

1. 日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。

2. 日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因或者受到攻击时攻击者留下的痕迹。

3. 可以这样理解**日志是用来记录重大事件的工具**

## 2、系统常见的日志

### a> 存放位置

​	`var/log/` 目录就是**系统日志文件的保存位置**

### b> 系统常用的日志

|          日志文件           |                             说明                             |
| :-------------------------: | :----------------------------------------------------------: |
| `/var/log/boot.log`【重要】 |                         系统启动日志                         |
|   `/var/log/cron`【重要】   |                 记录与系统定时任务相关的日志                 |
|      `/var/log/cups/`       |                      记录打印信息的日志                      |
|      `/var/log/dmesg`       | 记录了系统在开机时内核自检的信总。也可以使用 dmesg 命令直接查看内核自检信息 |
|       `/var/log/btmp`       | 记录错误登陆的日志。这个文件是二进制文件，不能直接用 Vi 查看，而要使用 lastb 命令查看。命令如下：<br>`[root@localhost log]#lastb` |
| `/var/log/lasllog`【重要】  | 记录系统中所有用户最后一次的登绿时间的日志。这个文件也是二进制文件.要使用 lastlog 命令查看 |
|  `/var/log/mailog`【重要】  |                      记录邮件信息的日志                      |
| `/var/log/message`【重要】  | 记录系统重要消息的日志，这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件 |
|  `/var/log/secure`【重要】  | 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 |
|       `/var/log/wtmp`       | 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。是二进制文件，而要使用 last 命令查看 |
|   `/var/tun/ulmp`【重要】   | 记录当前己经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登绿用户的信息。这个文件不能用 Vi 查看，而要使用 w、who、users 等命令查看 |

## 3、日志管理服务 rsyslogd

​	CentoS7.6 日志服务是 rsyslogd，CentOS6.x 日志服务是 syslogd。rsyslogd功能更强大。rsyslogd 的使用、日志文件的格式，和syslogd服务兼容的。

### a> 查询 rsyslogd 状态

查询 Linux 中的 rsyslogd 服务是否启动

​	`ps aux|grep "rsyslog"|grep -v "grep"`

> -v 表示反向匹配，这里的意思就是匹配前面不含 grep 的行

查询 rsyslogd 服务的自启动状态

​	`systemctl list-unit-files|grep rsyslog`

### b> 配置文件及类型

​	**配置文件**：`/etc/rsyslog.conf`

​	**编辑文件时的格式为**：`*.* 存放日志文件`

​	其中第一个 `*` 代表日志类型，第二个 `*` 代表日志级别

#### 1）日志类型分为

|          类型          |                  含义                  |
| :--------------------: | :------------------------------------: |
|         `auth`         |            ##pam产生的日志             |
|       `authpriv`       |     ##ssh、ftp等登录信息的验证信息     |
|         `corn`         |             ##时间任务相关             |
|         `kern`         |                 ##内核                 |
|         `lpr`          |                 ##打印                 |
|         `mail`         |                 ##邮件                 |
| `mark(syslog)-rsyslog` |       ##服务内部的信息，时间标识       |
|         `news`         |                ##新闻组                |
|         `user`         |        ##用户程序产生的相关信息        |
|         `uucp`         | ##unix to nuix copy 主机之间相关的通信 |
|      `local 1-7`       |           ##自定义的日志设备           |

#### 2）日志级别分为

|   级别    |                          含义                          |
| :-------: | :----------------------------------------------------: |
|  `debug`  |              ##有调试信息的，日志通信最多              |
|  `info`   |                 ##一般信息日志，最常用                 |
| `notice`  |             ##最具有重要性的普通条件的信息             |
| `warning` |                       ##警告级别                       |
|   `err`   |   ##错误级别，阻止某个功能或者模块不能正常工作的信息   |
|  `crit`   | ##严重级别，阻止整个系统或者整个软件不能正常工作的信息 |
|  `alert`  |                  ##需要立刻修改的信息                  |
|  `emerg`  |                  ##内核崩溃等重要信息                  |
|  `none`   |                     ##什么都不记录                     |

> 注意：从上到下，级别从低到高，记录信息越来越少

#### 3）查看日志

**由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下4段：**

​	1.事件产生的时间	（第一段）

​	2.产生事件的服务器的主机名	（第二段）

​	3.产生事件的服务名或程序名	（第三段）

​	4.事件的具体信息	（第四段）

**日志如何查看实例**

​	查看一下 `var/log/secure` 日志，这个日志中记录的是用户验证和授权方面的信息 来分析如何查看

### c> 应用实例

​	在 `/etc/rsyslog.conf` 中添加一个日志文件 `/var/log/hsp.log` ，当有事件发送时（比如 sshd 服务相关事件），该文件会接收到信息并保存，给小伙伴演示重启，登录的情况，看看是否有日志保存

1、在 /etc 目录下修改 rsyslog.conf 文件

​	`vim /etc/rsyslog.conf`

2、增加自定义的日志

​	`*.*			/var/log/xiaohu.log` 	（将任意级别的信息记录到 xiaohu.log 日志中）

## 4、日志轮替

### a> 基本介绍

​	日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后就会进行删除

### b> 日志轮替文件命名

​	1. centos7 使用 logrotate 【全局的日志轮替策略/规则】进行日志轮替管理，要想改变日志轮替文件名字，通过 `/etc/logrotate.conf` 配置文件中 `"dateext"` 参数：

​	2. 如果配置文件中有 `"dateext"` 参数，那么日志会用**日期**来作为日志文件的后缀，例如 `"secure-20201010"` 。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。

​	3. 如果配置文件中没有 `"dateext"` 参数，日志文件就需要进行改名了。当第一次进行日志轮替时，**当前的 `"secure"` 日志会自动改名为 `"secure.1”` ，然后新建 `"secure"` 日志，用来保存新的日志**。当第二次进行日志轮替时，`"secure.1”` 会自动改名为 `"secure.2"` ，当前的 `"secure"` 日志会自动改名为 `"secure.1"` ，然后也会新建 `"secure"` 日志，用来保存新的日志，以此类推。

### c> logrotate 配置文件

`/etc/logrotate.conf` 为 logrotate 的全局配置文件



​	1.`#rotate log files weekly` ，每周对日志文件进行一次轮替

​			`weekly`

​	2.`#keep4 weeks worth of backlogs` ，共保存4份日志文件，当建立新的日志文件时，旧的将会被删除

​	`rotate 4`

​	3.`#create new(empty) log files after rotating old ones` ，创建新的空的日志文件，在日志轮替后

​			`create`

​	4.`#use date as a suffix of the rotated file` ，使用日期作为日志轮替文件的后缀

​			`dateext`

​	5.`#uncomment this if you want your log files compressed` ，日志文件是否压缩。如果取消注释，则旧志会在转储的同时进行压缩

​			`#compress`

​	6.`#RPM packages drop log rotation information into this directory` 

​			`include /etc/logrotate.d`

​		#包含 `/etc/logrotate.d/` 目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来

> `/etc/logrotate.d/` 用来放置自己单独设置的轮替规则，及存放自己设置的规则的地方



#下面是**单独设置，优先级更高**。

`no packages own wtmp and btmp --we'll rotate them here`

```shell
/var/log/wtmp{
	monthly #每月对日志文件进行一次轮替
	create 0664 root utm p#建立的新日志文件，权限是0664，所有者是root,所属组是utmp组
	minsize 1M #日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行日志转储
	rotate1 #仅保留一个日志备份。也就是只有 wtmp 和 wtmp.1 日志保留而已
	}
```

```shell
/yar/log/btmp{
    missingok #如果日志不存在，则忽略该日志的警告信息
    monthly
    create 0600 root utmp
    rotate 1
    }
```

### d> logrotate 配置文件

#### 1. 参数说明

|           参数            |                           参数说明                           |
| :-----------------------: | :----------------------------------------------------------: |
|          `daily`          |                     日志的轮替周期是每天                     |
|         `weekly`          |                     日志的轮替周期是每周                     |
|         `monthly`         |                     日志的轮替周期是每月                     |
|       `rotate 数字`       |              保留的日志文件的个数。0指没有备份               |
|        `compress`         |                 日志轮替时，旧的日志进行压缩                 |
| `create mode owner group` |       建立新日志，同时指定新日志的权限与所有者和所属组       |
|      `mail address`       |      当日志轮替时，输出内容通过邮件发送到指定的邮件地址      |
|        `missingok`        |            如果日志不存在，则忽略该日志的警告信息            |
|       `notifempty`        |              如果日志为空文件，则不进行日志轮替              |
|      `minsize 大小`       | 日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替 |
|        `size 大小`        |    日志只有大于指定大小才进行日志轮替，而不是按照时间轮替    |
|         `dateext`         |                使用日期作为日志轮替文件的后缀                |
|      `sharedscripts`      |                在此关键字之后的脚本只执行一次                |
|   `prerotate/endscript`   |                  在日志轮替之前执行脚本命令                  |
|  `postrotate/endscript`   |                  在日志轮替之后执行脚本命令                  |

#### 2. 将自己的日志加入日志轮替

**第一种方法**：

​	是直接在 `/etc/logrotate.conf` 配置文件中写入该日志的轮替策略

**第二种方法**：

​	是在 `/etc/logrotate.d/` 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被 `"include"` 到主配置文件中，所以也可以把日志加入轮替。

​	**推荐使用第二种方法**，因为系统中需要轮替的日志非常多，如果全都直接写入 `/etc/logrotate.conf` 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。

​	在 `/etc/logrotate.d/` 配置轮替文件一览

#### 3. 应用实例

​	看一个案例，在 `/etc/logrotate.conf` 进行配置，或者直接在 `/etc/logrotate.d/` 下创建文件 hsplog 编写如下内容，具体轮替的效果可以参考 `var/log` 下的 `boot.log` 情况。

```shell
/var/log/hsp.log
{
    missingok
    daily
    copytruncate
    rotate 7
    notifempty
}
```

#### 4. 日志轮替机制原理

​	日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在 `/etc/cron.daily/` 目录，就会发现这个目录中是有 `logrotate` 文件（可执行），`logrotate` 通过这个文件依赖定时任务执行的。

## 5、查看内存日志

​	journalctl 可以查看内存日志，这里我们看看常用的指令

|                  指令                  |                             含义                             |
| :------------------------------------: | :----------------------------------------------------------: |
|              `journalctl`              |                          ##查看全部                          |
|           `journalctl -n 3`            |                        ##查看最新3条                         |
| `journalctl -since19:00-until19:10:10` |            ##查看起始时间到结束时间的日志可加日期            |
|          `journalctl -p err`           |                          ##报错日志                          |
|        `journalctl -o verbose`         |                        ##日志详细内容                        |
|    `journalctl_PID=1245 _COMM=sshd`    | ##查看包含这些参数的日志（在详细日志查看）<br>或者 `journalctl|grep sshd` |

​	注意：journalctl 查看的是**内存日志，重启清空**

演示案例：

​	使用 journalctl丨grep sshd 来看看用户登录清空，重启系统，再次查询，看看日志有什么变化没有.

# 十九、定制自己的Linux系统

## 1、基本介绍

​	通过裁剪现有 Linux 系统(CentOS7.6)，创建属于自己的 min Linux 小系统，可以加深我们对 Linux 的理解。老韩利用 centos7.6 ，搭建一个小小 Linux 系统，很有趣。

## 2、启动流程介绍

**制作 Linux 小系统之前，再了解一下 Linux 的启动流程：**

​	1. 首先Liux要通过自检，检查硬件设备有没有故障

​	2. 如果有多块启动盘的话，需要在BIOS中选择启动磁盘

​	3. 启动MBR中的bootloader引导程序

​	4. 加载内核文件

​	5. 执行所有进程的父进程、老祖宗systemd

 	6. 欢迎界面

**在 Linux 的启动流程中，加载内核文件时关键文件：**

​	1) kernel 文件：`vmlinuz-3.10.0-957.el7.x86_64`

​	2) initrd 文件：`initramfs-3.10.0-957.el7.x86_64.img` 

## 3、制作 min Linux 思路分析

​	1. 在现有的 Linux 系统 (centos7.6) 上加一块硬盘 /dev/sdb ，在硬盘上分两个分区，一个是 /boot ，一个是 / ，并将其格式化。需要明确的是，现在加的这个硬盘在现有的 Linux 系统中是 /dev/sdb ，但是，当我们把东西全部设置好时，要把这个硬盘拔除，放在新系统上，此时，就是 /dev/sda

​	2. 在 /dev/sdb 硬盘上，将其打造成独立的 Linux 系统，里面的所有文件是需要拷贝进去的

​	3. 作为能独立运行的 Linux 系统，内核是一定不能少，要把内核文件和 initramfs 文件也一起拷到 /dev/sdb 上

	4. 以上步骤完成，我们的自制 Linux 就完成，创建一个新的 linux 虚以机，将其硬盘指向我们创建的硬盘，启动即可

![](image\定制Linux原理图.png)

## 4、流程

1. 首先，我们在现有的 linux 添加一块大小为20G的硬盘

   > 注意，将**虚拟磁盘存储为单个文件**
   >
   > 存放在一个好找的位置，后缀名为 .vmdk
   >
   > 点击完成，就OK了， 可以使用 lsblk 查看，需要重启

2. 添加完成后，点击确定，然后启动现有的linux(centos7.6)。 通过fdisk来给我们的/dev/sdb进行分区

```shell
 1 [root@localhost ~]# fdisk /dev/sdb
 2 Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
 3 Building a new DOS disklabel with disk identifier 0x4fde4cd0.
 4 Changes will remain in memory only, until you decide to write them.
 5 After that, of course, the previous content won't be recoverable.
 6 
 7  
 8 Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)
 9 
10  
11 WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
12 switch off the mode (command 'c') and change display units to
13 sectors (command 'u').
14 
15 
16 Command (m for help): n
17 Command action
18 e extended
19 p primary partition (1-4)
20 p
21 Partition number (1-4): 1
22 First cylinder (1-2610, default 1):
23 Using default value 1
24 Last cylinder, +cylinders or +size{K,M,G} (1-2610, default 2610): +500M
25 
26 
27 Command (m for help): n
28 Command action
29 e extended
30 p primary partition (1-4)
31 p
32 Partition number (1-4): 2
33 First cylinder (15-2610, default 15):
34 Using default value 15
35 Last cylinder, +cylinders or +size{K,M,G} (15-2610, default 2610):
36 Using default value 2610
37 #查看分区
38 Command (m for help): p
39 
40  
41 Disk /dev/sdb: 21.5 GB, 21474836480 bytes
42 255 heads, 63 sectors/track, 2610 cylinders
43 Units = cylinders of 16065 * 512 = 8225280 bytes
44 Sector size (logical/physical): 512 bytes / 512 bytes
45 I/O size (minimum/optimal): 512 bytes / 512 bytes
46 Disk identifier: 0x4fde4cd0
47 
48  
49 Device Boot Start End Blocks Id System
50 /dev/sdb1 1 14 112423+ 83 Linux
51 /dev/sdb2 15 2610 20852370 83 Linux
52 #保存并退出
53 Command (m for help): w
54 The partition table has been altered! 
```

3. 接下来，我们对/dev/sdb的分区进行格式化

   `[root@localhost ~]# mkfs.ext4 /dev/sdb1`

   `[root@localhost ~]# mkfs.ext4 /dev/sdb2 `

4. 创建目录，并挂载新的磁盘

   `#mkdir -p /mnt/boot /mnt/sysroot `

   `#mount /dev/sdb1 /mnt/boot `

   `#mount /dev/sdb2 /mnt/sysroot/ `

5. 安装grub, 内核文件拷贝至目标磁盘

   `#grub2-install --root-directory=/mnt /dev/sdb`

   #我们可以来看一下二进制确认我们是否安装成功

   `#hexdump -C -n 512 /dev/sdb  `

   `#cp -rf /boot/* /mnt/boot/`

6.  修改 grub2/grub.cfg 文件, 标红的部分 是需要使用 指令来查看的

![](image\UUID.png)

​	在 grub.cfg 文件中 , 红色部分用 上面 sdb1 的 UUID替换，蓝色部分用 sdb2的UUID来替换, 紫色部分是添加的，表示

​	selinux给关掉，同时设定一下init，告诉内核不要再去找这个程序了，不然开机的时候会出现错误的

```shell
### BEGIN /etc/grub.d/10_linux ###
menuentry 'CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-957.el7.x86_64-advanced-2eef594e-68fc-49a0-8b23-07cf87dda424' {
	load_video
	set gfxpayload=keep
	insmod gzio
	insmod part_msdos
	insmod ext2
	set root='hd0,msdos1'
	if [ x$feature_platform_search_hint = xy ]; then
	  search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 
	  --hint='hd0,msdos1'  【6ba72e9a-19ec-4552-ae54-e35e735142d4】【1.红色】
	else
	  search --no-floppy --fs-uuid --set=root 【6ba72e9a-19ec-4552-ae54-e35e735142d4】【2.红色】
	fi
	linux16 /vmlinuz-3.10.0-957.el7.x86_64 root=UUID=【d2e0ce0f-e209-472a-a4f1-4085f777d9bb】【1.蓝色】 ro crashkernel=auto rhgb quiet LANG=zh_CN.UTF-8  【selinux=0 init=/bin/bash】【1.紫色，新增】
	initrd16 /initramfs-3.10.0-957.el7.x86_64.img
}
menuentry 'CentOS Linux (0-rescue-5bd4fb8d8e9d4198983fc1344f652b5d) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-0-rescue-5bd4fb8d8e9d4198983fc1344f652b5d-advanced-2eef594e-68fc-49a0-8b23-07cf87dda424' {
	load_video
	insmod gzio
	insmod part_msdos
	insmod ext2
	set root='hd0,msdos1'
	if [ x$feature_platform_search_hint = xy ]; then
	  search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 --hint='hd0,msdos1'  【6ba72e9a-19ec-4552-ae54-e35e735142d4】【3.红色】
	else
	  search --no-floppy --fs-uuid --set=root 【6ba72e9a-19ec-4552-ae54-e35e735142d4】【4.红色】
	fi
	linux16 /vmlinuz-0-rescue-5bd4fb8d8e9d4198983fc1344f652b5d root=UUID=【d2e0ce0f-e209-472a-a4f1-4085f777d9bb】【2.蓝色】 ro crashkernel=auto rhgb quiet 【 selinux=0 init=/bin/bash 】【2.紫色，新增】
	initrd16 /initramfs-0-rescue-5bd4fb8d8e9d4198983fc1344f652b5d.img
}

### END /etc/grub.d/10_linux ###

```

7. 创建目标主机根文件系统

   `#mkdir -pv /mnt/sysroot/{etc/rc.d,usr,var,proc,sys,dev,lib,lib64,bin,sbin,boot,srv,mnt,media,home,root}`

8. 拷贝需要的bash（也可以拷贝你需要的指令）和库文件给新的系统使用

   `#cp /lib64/*.* /mnt/sysroot/lib64/ `

   `#cp /bin/bash /mnt/sysroot/bin/ `

9. 现在我们就可以创建一个新的虚拟机，然后将默认分配的硬盘 移除掉，指向我们刚刚创建的磁盘即可。

   > 出现 bash-4.2# 就表示成功了

10. 这时，很多指令都不能使用，比如 ls , reboot 等，可以将需要的指令拷贝到对应的目录即可

11. 如果要拷贝指令，**重新进入到原来的 linux 系统拷贝相应的指令即可**，比较将 /bin/ls 拷贝到 /mnt/sysroot/bin 将 /sbin/reboot 拷贝到 /mnt/sysroot/sbin 

    `root@hspedu100 ~]# mount /dev/sdb2 /mnt/sysroot/`

    `[root@hspedu100 ~]# cp /bin/ls /mnt/sysroot/bin/`

    `[root@hspedu100 ~]# cp /bin/systemctl /mnt/sysroot/bin/`

    `[root@hspedu100 ~]# cp /sbin/reboot /mnt/sysroot/sbin/`

12. 再重新启动新的 min linux 系统，就可以使用 ls , reboot 指令了

# 二十、备份与恢复

## 1、基本介绍

​	实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，还会造成数据丢失。所以我们可以使用备份和恢复技术

​	Linux的备份和恢复很简单，有两种方式：

​	1. 把需要的文件（或者分区）用TAR打包就行，下次需要恢复的时候，再解压开覆盖即可

​	2. 使用dump和restore命令

## 2、安装 dump 和 restore

​	如果 linux 上没有 dump 和 restore 指令，需要先安装

​	`yum -y install dump`

​	`yum -y install restore`

## 3、使用 dump 完成备份

### a> 基本介绍

​	dump支持分卷和增量备份（所谓增量备份是指备份上次备份后 修改/增加过的文件，也称差异备份）。

### b> dump 语法说明

​	`dump [-cu] [-123456789] [-f<备份后文件名>] [-T<日期>] [目录或文件系统]`

​	`dump []-wW`

|        指令        |                             解释                             |
| :----------------: | :----------------------------------------------------------: |
|        `-c`        | 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头 |
|   `-0123456789`    | 备份的层级。0为最完整备份，会备份所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替 |
| `-f<备份后文件名>` |                       指定备份后文件名                       |
|        `-j`        | 调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩诚 bz2 格式，让文件更小 |
|     `-T<日期>`     |                   指定开始备份的时间与日期                   |
|        `-u`        | 备份完毕后，在 `/etc/dumpdares` 中记录备份的文件系统，层级，日期与时间等 |
|        `-t`        |       指定文件名，若该文件已存在备份文件中，则列出名称       |
|        `-W`        |     显示需要备份的文件及其最后一次备份的层级，时间，日期     |
|        `-w`        |             与 `-W` 类似，但仅显示需要备份的文件             |

### c> 使用 dump 完成备份

#### 1）dump应用案例1

将 /boot 分区所有内容备份到 /opt/boot.bak0.bz2 文件中，备份层级为 "0"

`dump -0uj -f /opt/boot.bak0.bz2 /boot`	（解读：使用 dump 以第0级别的备份方式，创建新的归档文件，调用 bzlib 库压缩备份文件，并指定文件后缀名为 .bak0.bz2 备份 /boot分区）

#### 2）dump应用案例2

在 /boot 目录下拷贝一个文件，备份层级为 "1"（只备份上次使用层次 "0" 备份后发生过改变的数据），**注意比较看看这次生成的备份文件 boot1.bak 有多大**

`dump -luj -f /opt/boot.bak1.bz2 /boot`

老韩提醒：通过 dump 命令在配合 crontab 可以实现无人值守备份

#### 3）指令1

​	`dump -W`

显示需要备份的文件及其最后一次备份的层级，时间，日期

#### 4）指令2

​	查看备份时间文件

`cat /etc/dumpdates`

#### 5）dump备份文件或者目录

前面我们在备份分区时，是可以支持增量备份的，**如果备份文件或者目录，不再支持增量备份，即只能使用0级别备份**

​	案例，使用 dump 备份 /etc 整个目录

​		`dump -0j -f /opt/etc.bak.bz2 /etc/`

​	#下面这条语句会报错，提示 `DUMP:Only level 0 dumps are allowed on a subdirectory`

​		`dump -1j -f /opt/etc.bak.bz2 /etc/`

​	老韩提醒：

​		**如果是重要的备份文件，比如数据区，建议将文件上传到其它服务器保存，不要将鸡蛋放在同一个篮子**

## 4、使用 restore 完成恢复

### a> 基本介绍

​	restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件

### b> restore基本语法

`restore [模式选项] [选项]`

**说明下面四个模式，不能混用，在一次命令中，只能指定一种。**

| 模式选项 |                            解释                            |
| :------: | :--------------------------------------------------------: |
|    -C    |      使用对比模式，将备份的文件与已存在的文件相互对比      |
|    -i    | 使用交互模式，在进行还原操作时，restors 指令将依序询问用户 |
|    -r    |                        进行还原模式                        |
|    -t    |               查看模式，看备份文件有哪些文件               |

**选项**：

|     选项     |                   解释                   |
| :----------: | :--------------------------------------: |
| -f<备份设备> | 从指定的文件中读取备份数据，进行还原操作 |

### c> 案例

#### 1）应用案例1

restore 命令比较模式，比较备份文件和原文件的区别

测试：

​	`mv /boot/hello.java /boot/hello100.java`

​	`restore -C -f boot.bak1.bz2` //注意和最新的文件比较

#### 2）应用案例2

restore 命令查看模式，看备份文件有哪些数据 / 文件

测试：

​	`restore -t -f boot.bak0.bz2`

#### 3）应用案例3

restore 命令还原模式，注意细节：如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件，就要恢复几个，按顺序来恢复即可。

测试：

​	`mkdir /opt/boottmp`

​	`cd /opt/boottmp`

​	`restore -r -f /opt/boot.bak0.bz2` //恢复到第1次完全备份状态

​	`restore -r -f /opt/boot.bak1.bz2` //恢复到第2次增量备份状态

#### 4）应用案例4

restore 命令恢复备份的文件，或者整个目录的文件

**基本语法**：`restore -r -f 备份好的文件`

测试：

​	`[root@hspedu100 opt]#mkdir etctmp`

​	`[root@hspedu100 opt]#cd etctmp/`

​	`[root@hspedu100 etctmp]#restore -r -f /opt/etc.bak0.bz2`

# 二十一、Linux可视化管理

## 1、webmin

### a> 基本介绍

​	Webmin 是功能强大的基于 Web 的 Unix/Linux 系统管理工具。管理员通过浏览器访问 Webmin 的各种管理功能并完成相应的管理操作。除了各版本的linux 以外还可用于：AIX、HPUX、Solaris、Unixware、Irix 和 FreeBSD 等系统

### b> 安装 webmin & 配置

1）下载地址：`http://download.webmin.com/download/yum/` ，用下载工具下载即可

也可以使用 `wget http://download.webmin.com/download/yum/webmin-l.700-1.noarch.rpm`

2）安装：`rpm -ivh webmin-1.700-1.noarch.rpm`

3）重置密码 `/usr/libexec/webmin/changepass.pl /etc/webmin root test`

`root` 是 `webmin` 的用户名，不是 `OS` 的，这里就是把 `webmin` 的 `root` 用户密码改成了 `test`

4）修改 `webmin` 服务的端口号（默认是 10000 出于安全目的）

`vim /etc/webmin/miniserv.conf` #修改端口

将 `port=10000` 修改为其他端口号，如 `port=6666`

5）重启 webmin

`/etc/webmin/restart` #重启

`/etc/webmin/start` #启动

`/etc/webmin/stop` #停止

6）防火墙放开6666端口

`firewall-cmd --zone=public --add-port=6666/tcp --permanent` #配置防火墙开放6666端口

`firewall-cmd --reload` #更新防火墙配置

`firewall-cmd --zone=public --list-ports` #查看已经开放的端口号

7）登录 webmin

`http://ip:6666`可以访问了

用 root 账号和重置的新密码 test

### c> 使用演示

#### 1）设置语言

![](image\设置语言1.png)

![设置语言2](image\设置语言2.png)

## 2、bt（宝塔）

### a> 基本介绍

​	bt 宝塔 Linux 面板是提升运维效率的服务器管理软件，支特一键 LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等多项服务器管理功能。

### b> 安装和使用

1. 安装： `yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh`

   > && 表示连字符，表示将几个命令连接在一起执行，类似于分步执行命令，先执行一步，再执行一步

2. 安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录，

   > 外网面板地址:` http://221.232.30.78:8888/6ed9ad60`
   > 内网面板地址:` http://192.168.200.131:8888/6ed9ad60`
   > username: n9iczmrm
   > password: 76cde0ce

3. 如果忘记密码，可以使用 bt default 可以查看